<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>ygopro源码分析2:lua的使用</title><url>http://rayrain.xyz/post/ygopro2/</url><categories/><tags><tag>ygopro</tag></tags><content type="html"> lua简介 lua是一门嵌入式的脚本语言,其存在的意义就是给C/C++等高级语言打下手,当一个好配角.
对于C/C++来说,lua的作用主要体现在:在C/C++程序没有重新编译,甚至没有重启的情况下,只通过改变lua脚本的内容,令C/C++程序做出不一样的行为,本文中以C语言为例.
一些有用的链接,全部啃完就能成为lua中级高手了.
lua菜鸟教程
lua5.3官方手册
lua程序设计
ygopro卡片脚本编写教程
只是窥探ocgcore的究竟的话,没必要啃那么多, 下面会讲解一些阅读ocgcore代码所需要用到的lua技能.
准备 需要有一个lua5.3的命令行程序,也就是上一篇文章中被删掉了luac.c文件.可以去官网直接下载,也可以再开个工程连同luac.c编译一遍.记得exe文件要放进环境变量PATH里面.
vscode下载lua相关插件
创建一个cmake工程,使用上一篇文章的方法 通过cmake编译lua库,然后连接到我们将要编写的c程序.
lua语法 lua的语法特别简单,首先建议阅读"lua菜鸟教程",不用全部读完,把变量 函数 分支循环 这些编程语言共有的内容都读完就可以了.大概半小时内就可以完成.
table表 table是lua中最重要的类型,什么都能存放,键值对,套娃就不多说了,大部分教程已经说的很清楚了.
最重要的是,它还能存放函数,但函数实际上就是一些字符串而已,一个table存放一些函数名 和 存放一些字符串 这两个行为,是一样的.唯一区别就是 lua的全局空间里已经提前注册好了相关函数
元表和元方法 元表首先是一个表,但它孤立存在没有意义,它需要"挂"在另一个表上当"工具人",才能成为元表.
--把metatable设置成table的元表 我们称table是主表 setmetatable(table,metatable) 如果元表只是当"挂件"的话,也同样没有意义,既然是"工具人"那肯定得有一些特殊的功能/函数.
元表的作用:当主表进行了某些未定义的操作时,主表会让元表站出来帮它完成这些操作.
实际上这些"未定义的操作",lua官方已经为我们定义好了一堆key来对应那些未定义的操作,我们让相应的key对应自定义的函数
这样当主表进行了某些未定义的操作时,就会调用相应key的对应函数,这些函数就是元方法.
table = {} --将要成为主表 metatable = {} --将要成为元表 indextable = {value = 10} --设置索引专用表 setmetatable(table,metatable) --设置metatable作为table的元表 --index 操作(指查询主表中不存在的元素) metatable.__index = indextable print(table.value) --输出结果:10 当查询table里不存在的元素时,就会去__index指向的indextable寻找
--add元方法 metatable.__add = function (op1,op2) print("this is add!") return "return 'add'" end print(table + table) --输出结果: this is add! return 'add' C API 更多时候lua是作为一个库来使用的,命令行程序luac只是lua库的副产物,其核心是使用了lua_pcall函数,一共只有400多行.
lua可以嵌入到C程序里,但lua和C是两个完全不一样的世界,lua中的变量只能由lua管理,C语言中的值lua也不知道,双方只能通过一个虚拟栈来交换信息.C和lua之间也主要是围绕着"lua虚拟栈" &ldquo;lua环境&rdquo; &ldquo;C环境&rdquo; 编程的.
创建一个lua对象 lua_State *L = luaL_newstate(); 虚拟栈 lua虚拟栈是这样的--> | 栈顶 | 索引值:-1 -------- | | ------- | 栈底 | 索引值:1 ------- 和一般的栈没有什么不同 push类函数 C &ndash;> stack 这类函数的作用是:将C中生成的变量入栈
LUA_API void (lua_pushnil) (lua_State *L); LUA_API void (lua_pushnumber) (lua_State *L, lua_Number n); LUA_API void (lua_pushinteger) (lua_State *L, lua_Integer n); LUA_API const char *(lua_pushlstring) (lua_State *L, const char *s, size_t len); LUA_API const char *(lua_pushstring) (lua_State *L, const char *s); LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt, va_list argp); LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...); LUA_API void (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n); LUA_API void (lua_pushboolean) (lua_State *L, int b); LUA_API void (lua_pushlightuserdata) (lua_State *L, void *p); LUA_API int (lua_pushthread) (lua_State *L); set类函数 stack &ndash;> lua 这类函数的作用是:弹出栈顶的元素,然后将其设置为其他变量的某值
LUA_API void (lua_setglobal) (lua_State *L, const char *name); LUA_API void (lua_settable) (lua_State *L, int idx); LUA_API void (lua_setfield) (lua_State *L, int idx, const char *k); LUA_API void (lua_seti) (lua_State *L, int idx, lua_Integer n); LUA_API void (lua_rawset) (lua_State *L, int idx); LUA_API void (lua_rawseti) (lua_State *L, int idx, lua_Integer n); LUA_API void (lua_rawsetp) (lua_State *L, int idx, const void *p); LUA_API int (lua_setmetatable) (lua_State *L, int objindex); LUA_API void (lua_setuservalue) (lua_State *L, int idx); get类函数 lua &ndash;> stack 这类函数的作用是:将lua环境中存在的变量放入栈顶
LUA_API int (lua_getglobal) (lua_State *L, const char *name); LUA_API int (lua_gettable) (lua_State *L, int idx); LUA_API int (lua_getfield) (lua_State *L, int idx, const char *k); LUA_API int (lua_geti) (lua_State *L, int idx, lua_Integer n); LUA_API int (lua_rawget) (lua_State *L, int idx); LUA_API int (lua_rawgeti) (lua_State *L, int idx, lua_Integer n); LUA_API int (lua_rawgetp) (lua_State *L, int idx, const void *p); LUA_API void (lua_createtable) (lua_State *L, int narr, int nrec); LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz); LUA_API int (lua_getmetatable) (lua_State *L, int objindex); LUA_API int (lua_getuservalue) (lua_State *L, int idx); access类函数 stack &ndash;> C 这类函数的作用是:检查栈中的元素,将结果传入C环境中.或者直接将栈中的元素读到C环境中,这个操作不会影响栈
LUA_API int (lua_isnumber) (lua_State *L, int idx); LUA_API int (lua_isstring) (lua_State *L, int idx); LUA_API int (lua_iscfunction) (lua_State *L, int idx); LUA_API int (lua_isinteger) (lua_State *L, int idx); LUA_API int (lua_isuserdata) (lua_State *L, int idx); LUA_API int (lua_type) (lua_State *L, int idx); LUA_API const char *(lua_typename) (lua_State *L, int tp); LUA_API lua_Number (lua_tonumberx) (lua_State *L, int idx, int *isnum); LUA_API lua_Integer (lua_tointegerx) (lua_State *L, int idx, int *isnum); LUA_API int (lua_toboolean) (lua_State *L, int idx); LUA_API const char *(lua_tolstring) (lua_State *L, int idx, size_t *len); LUA_API size_t (lua_rawlen) (lua_State *L, int idx); LUA_API lua_CFunction (lua_tocfunction) (lua_State *L, int idx); LUA_API void *(lua_touserdata) (lua_State *L, int idx); LUA_API lua_State *(lua_tothread) (lua_State *L, int idx); LUA_API const void *(lua_topointer) (lua_State *L, int idx); load&amp;call类函数 这类函数的主要作用就是读取lua代码或者执行lua函数
LUA_API void (lua_callk) (lua_State *L, int nargs, int nresults, lua_KContext ctx, lua_KFunction k); #define lua_call(L,n,r) lua_callk(L, (n), (r), 0, NULL) LUA_API int (lua_pcallk) (lua_State *L, int nargs, int nresults, int errfunc, lua_KContext ctx, lua_KFunction k); #define lua_pcall(L,n,r,f) lua_pcallk(L, (n), (r), (f), 0, NULL) LUA_API int (lua_load) (lua_State *L, lua_Reader reader, void *dt, const char *chunkname, const char *mode); LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data, int strip); lua脚本的调用:
int32 error = luaL_loadbuffer(current_state, (char*)buffer, len, script_name) || lua_pcall(current_state, 0, 0, 0); luaL_loadbuffer函数最终会调用lua_load,将加载的脚本打包成一个function放入栈顶,最后由lua_pcall运行这个function,完成脚本的加载.从此,这个脚本的内容就在lua的环境里了,除了一些local修饰的内容,其余所有内容都能被任何其他脚本访问.
lua函数的执行
//ygopro里使用这个函数来运行lua函数 lua_pcall(L, //lua对象 n, //参数数量 r, //返回值的数量 f) //不关心这玩意 填0就行 //作用:运行栈顶上的函数,从栈上取出相应数量的参数,运行完之后将相应数量的返回值放入栈顶,供C读取 userdata userdata是一类特殊的数据,用来保存lua中没有的数据类型(一般是C中的指针)
//这个函数以给定的大小分配一个新的内存块，将一个新的完整的用户数据和块地址压入堆栈，并返回这个地址。主机程序可以自由地使用这些内存 LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz); 引用 //在t索引处 创建栈顶元素的引用,并返回引用值 这个操作会弹出栈顶元素 t索引处是个表 LUALIB_API int (luaL_ref) (lua_State *L, int t); //解除t处 ref代表的引用 LUALIB_API void (luaL_unref) (lua_State *L, int t, int ref); 引用建立完成之后大概是这样的,t索引处的表 添加了一对键值对
┌──────────table at t──────────────┐ │ │ │ │ │ key value │ │ │ │ │ │ ref = element from stack top │ │ │ │ └──────────────────────────────────┘ 关于引用的一个坑
luaL_ref会返回引用值ref,是int类型.
那么,lua实例创建的第一个引用的ref值是多少? 在lua5.3 中,这个值是3
在lua5.4 中,这个值是4
真的太cooool了!
duel* interpreter::get_duel_info(lua_State * L) { luaL_checkstack(L, 1, NULL); lua_rawgeti(L, LUA_REGISTRYINDEX, 3); //good job duel* pduel = (duel*)lua_topointer(L, -1); lua_pop(L, 1); return pduel; } 注册表 注册表是一种特别的表,它一直存在于虚拟栈中,但它是"隐形"的,所有操作栈的函数都会无视它的存在. 只能通过 &ldquo;LUA_REGISTRYINDEX&rdquo; 这个索引去访问它.
在ocgcore中,userdata 引用 注册表,这三者经常合在一起使用,比如下面的代码,在LUA_REGISTRYINDEX中注册了一个效果effect*
void interpreter::register_effect(effect *peffect) { if (!peffect) return; //create a effect in by userdata luaL_checkstack(lua_state, 3, NULL); effect ** ppeffect = (effect**) lua_newuserdata(lua_state, sizeof(effect*)); //在栈顶新建一块userdata,存储effect*变量,返回值类型是(effect**) *ppeffect = peffect; //新建的userdata存储的effect*变量 指向了形参 peffect peffect->ref_handle = luaL_ref(lua_state, LUA_REGISTRYINDEX); //将在在注册表中创建引用 //set metatable of pointer to base script lua_rawgeti(lua_state, LUA_REGISTRYINDEX, peffect->ref_handle); lua_getglobal(lua_state, "Effect"); lua_setmetatable(lua_state, -2); lua_pop(lua_state, 1); } 这段程序运行之后会变成这样
┌───────LUA_REGISTRYINDEX───┐ │ │ │ │ │ key value │ │ │ ├┬────┐ │ ┌───────────┐ ││ref │ peffect ────┼───► │ │┼────┤ │ │ effect │ └───┼─┴─────────────────────┘ │ │ │ └─────┬─────┘ │ │ └─────────────────────────────────┴─ "Effect"是 peffect的元表 为什么要这么麻烦设置这么一堆东西?
通过ref可以立即获取到userdata到栈上
userdata是指针,是未知类型的,指向的内容未知,
这时,可以获取它的元表,看元表是什么,如果元表是"Effect",代表这个指针指向effect,如果元表是"Card",代表这个指针指向card&hellip;&hellip;
lua调用C函数 编写脚本时,我们可以使用5个函数库: Card 库，Group 库，Effect 库，Duel 库以及 Auxiliary 库
其中Auxiliary库是一个需要加载的lua文件,其余4个全部都是调用的C++函数,是写死在ocgcore中的.
拿一个最短的Duel库来举例: `` static const struct luaL_Reg debuglib[] = { { &ldquo;Message&rdquo;, scriptlib::debug_message }, { &ldquo;AddCard&rdquo;, scriptlib::debug_add_card }, { &ldquo;SetPlayerInfo&rdquo;, scriptlib::debug_set_player_info }, { &ldquo;PreSummon&rdquo;, scriptlib::debug_pre_summon }, { &ldquo;PreEquip&rdquo;, scriptlib::debug_pre_equip }, { &ldquo;PreSetTarget&rdquo;, scriptlib::debug_pre_set_target }, { &ldquo;PreAddCounter&rdquo;, scriptlib::debug_pre_add_counter }, { &ldquo;ReloadFieldBegin&rdquo;, scriptlib::debug_reload_field_begin }, { &ldquo;ReloadFieldEnd&rdquo;, scriptlib::debug_reload_field_end }, { &ldquo;SetAIName&rdquo;, scriptlib::debug_set_ai_name }, { &ldquo;ShowHint&rdquo;, scriptlib::debug_show_hint }, { NULL, NULL } }; void scriptlib::open_debuglib(lua_State *L) { luaL_newlib(L, debuglib); lua_setglobal(L, &ldquo;Debug&rdquo;); }
`` 可以看出来:这些函数确实是"Debug"里的一个普通字符串.调用方法是Debug.XXXXXX
编写卡片脚本看见拿不准的函数时,可以去看一下对应的C++函数具体都干了些什么.
也可以自己添加新的函数,便于自己使用.</content></entry><entry><title>ygopro源码分析1:源码的获取&编译</title><url>http://rayrain.xyz/post/ygopro1/</url><categories/><tags><tag>ygopro</tag></tags><content type="html"> 1.简介 ygopro是一个开源免费的游戏王模拟器,原作者是Fluorohydride(圆神),可以模拟几乎所有的游戏王卡片,并且在源码的级别上同时支持windows linux 和macos等操作系统.圆神神隐后由决斗者们维护到现在,主要有mycard和233两个服务器.
源码由3部分组成,还用了若干的第三方库.
ygopro:游戏的客户端本体
|-irrlicht:游戏引擎,负责游戏画面和GUI
|-freetype:字体引擎,负责让irrlicht显示中文
|-sqlite3:轻量级数据库,存储卡片的数据,用于卡片的查找搜寻
|-libevent2:网络库,实现联机对战
|-lzma:压缩算法,用于游戏录像文件
|-IrrKlang:音频引擎
ocgcore:脚本处理引擎
|-lua5.3:用于读取各种脚本
script:lua编写的卡片脚本
需要用到的软件 git vscode cmake msvc(需要安装visual studio获取) sqlitebrowser: 用于浏览card数据库 DataEditorX: ygopro的定制card数据库操作软件 vcpkg(可选): 可以更方便的管理第三方库 2.源码获取以及编译 2.1 下载源码 由于原版ygopro的代码过于感人,所以选用了KoishiPro.
KoishiPro是ygopro的pro版,代码比较规范.
git clone --recurse https://github.com/purerosefallen/ygopro.git 这个命令可以源码的3部分全部下载下来.不包括第三方库.
(如果你使用的是ubuntu系的linux的话,直接安装好相关的库,然后cmake就能一键编译了,本文就不用看了)
ygopro的官方貌似使用premake来构筑代码,但也有人为其编写CMake脚本,接下来我们会使用cmake来构筑代码.
2.2 使用vs编译 我不喜欢VS这种重量级的IDE,如果想要用VS编译的话,可以参考尸体233的Travis CI脚本, 或者KoishiPro自带的编译脚本. 手动按照脚本中的步骤一步步操作,可以生成sln项目文件,然后就能用VS编译了,下面的内容就不用看了.
2.3 使用vscode编译 首先需要安装cmake cmaketool C++等插件
VS也得装,记得装C++开发环境,以获取msvc.
使用vcpkg管理第三方库 windows上没有包管理工具,想要用什么库都得手动下载,手动编译,而且大概率都是一次性使用,这个过程比较痛苦,如果不想这么麻烦的话建议使用vcpkg来管理第三方库.
具体使用方法我就不多说了,懂得都懂,官方文档.
不过使用这个方法需要稍微修改下CMakeLists.txt文件.
手动下载各个第三方库 先打开工程根目录的CMakeLists.txt,找到这部分
if (MSVC) add_subdirectory (event) add_subdirectory (freetype) add_subdirectory (irrlicht) add_subdirectory (sqlite3) add_subdirectory (lua) 可以看到,我们的目标就是在根目录创建上面相应的文件夹,同时每个文件夹根目录里都需要有一个CMakeLists.txt文件.
下面是各个库的下载地址(暂时忽略IrrKlang)
event
freetype
irrlicht
sqlite3
lua
然后我们把这些库都解压到工程的根目录下的相应文件夹下(这些文件夹需要自行修改成 event freetype irrlicht sqlite3 lua这些名字), 同时需要保证每个文件夹根目录里都需要有一个CMakeLists.txt文件.
目录大概是这样 |-ygopro ├─event │ └─CMakeLists.txt ├─freetype | └─CMakeLists.txt ├─irrlicht | └─CMakeLists.txt ├─sqlite3 | └─CMakeLists.txt ├─lua | └─CMakeLists.txt 记得用vscode打开ygopro工程文件夹.
修改部分CMakeLists.txt脚本 现在除了lua和sqlite3之外,其余3个库都已经准备好了CMakeLists.txt文件.
所以现在要为lua和sqlite3添加CMakeLists.txt编译脚本. #sqlite3的编译脚本 project(sqlite3) file(GLOB SQL_SRC ./*.c) add_library(sqlite3 STATIC ${SQL_SRC}) #lua的编译脚本 #需要删除 src/luac.c 这个是命令行程序,有main函数 project(lua) file(GLOB LUA_SRC ./src/*.c) add_library(lua STATIC ${LUA_SRC}) event的编译脚本需要做一些修改 #在前面的option部分 把EVENT__DISABLE_OPENSSL打开 ,关闭对openssl的依赖 option(EVENT__DISABLE_OPENSSL "Define if libevent should build without support for OpenSSL encryption" ON) event的编译脚本默认会编译一些test,我们不需要,
把995行 sample处 以下的内容全部注释
irrlicht设置不使用D3D9编译 //在IrrCompileConfig.h这个文件 (156行之前) 加入下面这行 #define NO_IRR_COMPILE_WITH_DIRECT3D_9_ 修改lua的路径 我们lua库的路径是 lua/src,ocgcore的CMakeLists需要修改成如下: project (ocgcore) set (AUTO_FILES_RESULT) AutoFiles("." "src" "\\.(cpp|c|h)$") if (MSVC) include_directories ( ../lua/src ) #正确的lua路径 else () include_directories ( ${LUA_INCLUDE_DIR} ) endif () add_library (ocgcore STATIC ${AUTO_FILES_RESULT}) if (MSVC) target_link_libraries (ocgcore lua) else () target_link_libraries (ocgcore ${LUA_LIBRARIES}) endif () 一些其他修改 lua.h相关 ocgcore是C++工程,应该把 interpreter.h中 14行 改成 lua.hpp 编译 使用vscode打开ygopro文件夹后,如果cmake tool 和C++插件被正确安装的话,最下方的栏位里会出现cmake的一些选项,其中kit能够识别出电脑上的编译环境. 我们选择kit为: &ldquo;Visual Studio Community 2019 -amd64_x86&rdquo;(不同电脑上可能有差异),然后点击build.经过一段时间后就可以编译出ygopro.exe文件了,到这里就算编译成功了.
编译技巧 可以看到根目录的CMakeLists.txt里有很多add_subdirectory,每一个都代表了一个project,为了方便的检测修改的CMakeLists.txt是否正确,可以先把其他的add_subdirectory注释掉,只留下一个,这样就可以逐个编译了.
BTW 另外cmake配合msvc使用是可以生成sln工程文件的,这时候就可以直接双击sln,使用vs来编译了.
一些可能的其他错误 我们下载的irrlicht是mycard特殊修改的版本,如果你使用的是其他地方的irrlicht,有可能会遇到问题.
这个地方c_str()的返回值是char*型,和 wchar_t*不符合,会报错 const wchar_t* fname = archive->getFullFileName(j).c_str(); 在合适的地方定义这个函数,可以将char* 转换成wchar_t*
#include &lt;stringapiset.h> wchar_t* AnsiToUnicode(const char* szStr) { int nLen = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szStr, -1, NULL, 0 ); if (nLen == 0) { return NULL; } wchar_t* pResult = new wchar_t[nLen]; MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szStr, -1, pResult, nLen ); return pResult; } 然后
把出错的这行改成 const wchar_t* fname =AnsiToUnicode( archive->getFullFileName(j).c_str()); 运行 打开mycard下的ygopro或者尸体233的ygopro的根目录,将pics(卡图目录),script(脚本目录),textures(游戏素材),cards.cdb(卡片数据库)和各种conf文件都复制到我们的编译目录,和ygopro.exe同级,然后就可以运行了. 输入
s1.ygo233.com 233 就可以和233服的玩家决斗了.
(建议把本工程的conf文件也放进去)</content></entry><entry><title>卡片脚本编写</title><url>http://rayrain.xyz/cardscript/</url><categories/><tags><tag>ygopro</tag><tag>lua</tag></tags><content type="html"> 杂记 永续魔法卡 等 发动后停留在场上,这个行为是客户端实现的 s代表自己 o代表对方
触发型效果 参数名 全称 含义 e Effect 这个效果本身 tp This Player 发动效果的玩家 eg Event Group 触发这个时点时涉及的卡片组 ep Event Player 触发这个时点时涉及的玩家 ev Event Value 触发这个时点时涉及的数值/连锁序号(仅限连锁相关的时点) re Reason Effect 触发这个时点的原因效果 r Reason 触发这个时点的原因 rp Reason Player 触发这个时点的原因玩家 Effect的属性 Category 卡片效果类型的tag,如:哥布林暴发户 的Category是
e1:SetCategory(CATEGORY_DRAW+CATEGORY_RECOVER) 抽卡效果 和 回复效果 抽卡效果可以被灰流丽响应
Type 指效果的类型
e1:SetType(EFFECT_TYPE_ACTIVATE) 魔陷发动,拥有这个类型才可以当作魔陷在魔陷区发动 Target SetRange 效果的生效位置,这张卡只有在生效位置再能发挥效果
e2:SetRange(LOCATION_SZONE) 该效果在魔陷区域才有效,离开后就无效了</content></entry><entry><title>ocgcore分析</title><url>http://rayrain.xyz/ygocore/</url><categories/><tags><tag>ygopro</tag><tag>lua</tag></tags><content type="html"> 简介 ygopro的核心被叫做ocgcore,实际上不止支持OCG,还支持TCG等等,顺带一提,早期的ygopro更多的被人称为ygocore,现在的相关贴吧还叫"游戏王ygocore"
记录 加载卡片脚本 int32 interpreter::load_card_script(uint32 code) { //假定code=123456 //首先看lua环境里面有没有 c123456这个变量,有的话就将这个变量放入栈顶 char class_name[20]; sprintf(class_name, "c%d", code); luaL_checkstack(current_state, 1, NULL); lua_getglobal(current_state, class_name); if (lua_isnil(current_state, -1)) { //没有c123456 所以放到栈顶的是nil luaL_checkstack(current_state, 5, NULL); lua_pop(current_state, 1); //弹出栈顶的nil lua_createtable(current_state, 0, 0); //创建一个空表到栈顶 lua_setglobal(current_state, class_name); //弹出空表,另c123456 = 空表 以下称table(c123456) lua_getglobal(current_state, class_name); //将table(c123456) 入栈 lua_getglobal(current_state, "Card"); //将"Card"入栈 lua_setmetatable(current_state, -2); //弹出栈顶的"Card" 将"Card"设置为table(c123456)的元表 lua_pushstring(current_state, "__index"); //字符串"__index"入栈 lua_pushvalue(current_state, -2); //table(c123456)复制一份到栈顶 lua_rawset(current_state, -3); //table(c123456).__index=table(c123456) char script_name[64]; sprintf(script_name, "./script/c%d.lua", code); if(!load_script(script_name)) { //加载相应的lua脚本文件 return OPERATION_FAIL; } } return OPERATION_SUCCESS; } 状态status 添加一个处理单元 void field::add_process(uint16 type, 此单元的类型 uint16 step, 这个单元的进度 effect* peffect, group* target, ptr arg1, ptr arg2, ptr arg3, ptr arg4, void* ptr1, void* ptr2) ┌────────────────┐ ┌─────────────────────┐ │ │ │ │ ┌────────────────────┐ │ │ │ │ data │ │ │ core ├──────────────── │ client │ ────────────── │ server │ │ │ │ │ │ │ └────────────────┘ │ │ │ │ └─────────────────────┘ └────────────────────┘ 16bit 8bit ┌────────────────┬────────┬──────────────────────────┐ │ │ │ │ │ len │ proto │ EX buffer │ └────────────────┴────────┴──────────────────────────┘ 8bit ┌────────┬──────────────┐ │ │ │ GAME_MSG │ msg │ buffer │ └────────┴──────────────┘ other_MSG</content></entry><entry><title>lua note</title><url>http://rayrain.xyz/lua/</url><categories/><tags><tag>lua</tag></tags><content type="html"> lua简介 lua是一门嵌入式的脚本语言,其存在的意义就是给C/C++等高级语言打下手,当一个好配角.
对于C/C++来说,lua的作用主要体现在:在C/C++程序没有重新编译,甚至没有重启的情况下,只通过改变lua脚本的内容,令C/C++程序做出不一样的行为.
一些有用的链接:
lua菜鸟教程
lua5.3官方手册
lua程序设计
lua实际上是一个库,命令行里的可交互程序luac是lua库的副产物,只有400多行,很少用到.
lua可以嵌入到C程序里,但lua和C是两个完全不一样的世界,lua中的变量只能由lua管理,C语言中的值lua也不知道,双方只能通过一个虚拟栈来交换信息.C和lua之间也主要是围绕着"lua虚拟栈" &ldquo;lua环境&rdquo; &ldquo;C环境&rdquo; 编程的.
本文中出现的lua API不一定全部解释,请查阅lua5.3官方手册
创建一个lua对象 lua_State *L = luaL_newstate(); lua虚拟栈 lua虚拟栈是这样的--> | 栈顶 | 索引值:-1 -------- | | ------- | 栈底 | 索引值:1 ------- 和一般的栈没有什么不同的 栈基本操作 //取出栈顶的元素,赋给全局变量,可以新建全局变量 LUA_API void (lua_setglobal) (lua_State *L, const char *name); //idx[k] = v v是索引-1处的值 , k是索引-2的值 //并将k和v 弹出堆栈 这个函数可以触发__newindex元方法 LUA_API void (lua_settable) (lua_State *L, int idx); //如果idx处是个table,弹出栈顶的元素 赋值给改table[k],k必须为字符串 LUA_API void (lua_setfield) (lua_State *L, int idx, const char *k); LUA_API void (lua_seti) (lua_State *L, int idx, lua_Integer n); //跟lua_settable一样 不会调用元方法 LUA_API void (lua_rawset) (lua_State *L, int idx); LUA_API void (lua_rawseti) (lua_State *L, int idx, lua_Integer n); LUA_API void (lua_rawsetp) (lua_State *L, int idx, const void *p); //从堆栈中弹出一个表，并将其设置为给定索引值objindex的新元表 LUA_API int (lua_setmetatable) (lua_State *L, int objindex); LUA_API void (lua_setuservalue) (lua_State *L, int idx); stack&ndash;>C //索引处是否是数字或可转换成数字的字符串 LUA_API int (lua_isnumber) (lua_State *L, int idx); //索引处 是否是字符串 或者可转换成字符串的数字 LUA_API int (lua_isstring) (lua_State *L, int idx); LUA_API int (lua_iscfunction) (lua_State *L, int idx); LUA_API int (lua_isinteger) (lua_State *L, int idx); LUA_API int (lua_isuserdata) (lua_State *L, int idx); LUA_API int (lua_type) (lua_State *L, int idx); LUA_API const char *(lua_typename) (lua_State *L, int tp); LUA_API lua_Number (lua_tonumberx) (lua_State *L, int idx, int *isnum); LUA_API lua_Integer (lua_tointegerx) (lua_State *L, int idx, int *isnum); LUA_API int (lua_toboolean) (lua_State *L, int idx); LUA_API const char *(lua_tolstring) (lua_State *L, int idx, size_t *len); LUA_API size_t (lua_rawlen) (lua_State *L, int idx); LUA_API lua_CFunction (lua_tocfunction) (lua_State *L, int idx); LUA_API void *(lua_touserdata) (lua_State *L, int idx); LUA_API lua_State *(lua_tothread) (lua_State *L, int idx); LUA_API const void *(lua_topointer) (lua_State *L, int idx); C&ndash;>stack //向栈中推入一个nil LUA_API void (lua_pushnil) (lua_State *L); //向栈中推入一个double数字 LUA_API void (lua_pushnumber) (lua_State *L, lua_Number n); //推入longlong数字 LUA_API void (lua_pushinteger) (lua_State *L, lua_Integer n); //推入字符串的前len个元素 LUA_API const char *(lua_pushlstring) (lua_State *L, const char *s, size_t len); //推入字符串 LUA_API const char *(lua_pushstring) (lua_State *L, const char *s); //va_list用法 LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,va_list argp); //推入格式化输出的字符串 LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...); //推入闭包 LUA_API void (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n); //推入布尔值 LUA_API void (lua_pushboolean) (lua_State *L, int b); //推入用户数据 LUA_API void (lua_pushlightuserdata) (lua_State *L, void *p); LUA_API int (lua_pushthread) (lua_State *L); lua&ndash;>stack //将存在的全局变量压入栈顶 LUA_API int (lua_getglobal) (lua_State *L, const char *name); //将存在的table 压入栈顶lua_setmetatable LUA_API int (lua_gettable) (lua_State *L, int idx); //如果idx索引处是table,将该table[k]放到栈顶,k必须为字符串 LUA_API int (lua_getfield) (lua_State *L, int idx, const char *k); LUA_API int (lua_geti) (lua_State *L, int idx, lua_Integer n); LUA_API int (lua_rawget) (lua_State *L, int idx); //将t[n]压入堆栈,t是索引idx处的表,不会调用__index元方法 LUA_API int (lua_rawgeti) (lua_State *L, int idx, lua_Integer n); LUA_API int (lua_rawgetp) (lua_State *L, int idx, const void *p); //创建一个空的table并压入栈中，并预分配narr个array元素的空间和预分配nrec个非array元素的空间 LUA_API void (lua_createtable) (lua_State *L, int narr, int nrec); //这个函数以给定的大小分配一个新的内存块，将一个新的完整的用户数据和块地址压入堆栈，并返回这个地址。主机程序可以自由地使用这些内存 LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz); LUA_API int (lua_getmetatable) (lua_State *L, int objindex); LUA_API int (lua_getuservalue) (lua_State *L, int idx); //如果idx处是一个table,获取该table的fname索引,并压入栈顶 LUALIB_API int (luaL_getsubtable) (lua_State *L, int idx, const char *fname); stack&ndash;>lua //取出栈顶的元素,赋给全局变量,可以新建全局变量 LUA_API void (lua_setglobal) (lua_State *L, const char *name); //idx[k] = v v是索引-1处的值 , k是索引-2的值 //并将k和v 弹出堆栈 这个函数可以触发__newindex元方法 LUA_API void (lua_settable) (lua_State *L, int idx); //如果idx处是个table,弹出栈顶的元素 赋值给改table[k],k必须为字符串 LUA_API void (lua_setfield) (lua_State *L, int idx, const char *k); LUA_API void (lua_seti) (lua_State *L, int idx, lua_Integer n); //跟lua_settable一样 不会调用元方法 LUA_API void (lua_rawset) (lua_State *L, int idx); LUA_API void (lua_rawseti) (lua_State *L, int idx, lua_Integer n); LUA_API void (lua_rawsetp) (lua_State *L, int idx, const void *p); //从堆栈中弹出一个表，并将其设置为给定索引值objindex的新元表 LUA_API int (lua_setmetatable) (lua_State *L, int objindex); LUA_API void (lua_setuservalue) (lua_State *L, int idx); load &amp; call LUA_API void (lua_callk) (lua_State *L, int nargs, int nresults, lua_KContext ctx, lua_KFunction k); #define lua_call(L,n,r) lua_callk(L, (n), (r), 0, NULL) LUA_API int (lua_pcallk) (lua_State *L, int nargs, int nresults, int errfunc, lua_KContext ctx, lua_KFunction k); #define lua_pcall(L,n,r,f) lua_pcallk(L, (n), (r), (f), 0, NULL) LUA_API int (lua_load) (lua_State *L, lua_Reader reader, void *dt, const char *chunkname, const char *mode); LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data, int strip); //加载一个文件并执行 #define luaL_dofile(L, fn) (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0)) 表和元方法 表是lua中用途最广泛的结构,
注册表和引用</content></entry><entry><title>hugo相关操作</title><url>http://rayrain.xyz/hugo_manual/</url><categories/><tags><tag>hugo</tag></tags><content type="html"> hugo简单操作
生成仓库中需要的内容 hugo 运行hugo服务器 hugo server push到仓库 git remote add origin git@github.com:Reisen1969/Reisen1969.github.io.git git push origin master</content></entry><entry><title>ygopro源码分析</title><url>http://rayrain.xyz/ygopro/</url><categories/><tags><tag>ygopro</tag></tags><content type="html"> 总览 1.简单介绍 ygopro是一个开源免费的游戏王模拟器,可以模拟几乎所有的游戏王卡片,并且在源码的级别上同时支持windows linux 和macos等操作系统,不过这个项目的创建者Fluorohydride(圆神)从2016年就神隠了,这个项目由一群爱好者一直维护,还有两个主要的对战服务器,233服和萌卡mycard.
本文的读者想必都是决斗者了,一些专有名词就不解释了,默认大家都懂了.
源码由3部分组成,还用了若干的第三方库.
ygopro:游戏的客户端本体 |-irrlicht:游戏引擎,负责游戏画面和GUI |-freetype:字体引擎,负责让irrlicht显示中文 |-sqlite3:轻量级数据库,存储卡片的数据,用于卡片的查找搜寻 |-libevent2:网络库,实现联机对战 |-lzma:压缩算法,用于游戏录像 ocgcore:脚本处理引擎 |-lua5.3:用于读取各种脚本 script:lua编写的卡片脚本 ygopro使用的音频引擎是irrKlang,不开源,我直接选择性忽略了.
我全程在archlinux上分析的源码,文中有关windows的地方我都验证过了
不会分析TAG模式和replay
2.前期准备 2.1 下载源码 git clone --recurse https://github.com/Fluorohydride/ygopro.git 这个命令可以源码的3部分全部下载下来.不包括第三方库.
然后就是编译了,打开文件夹后可以看到本项目似乎支持cmake和premake4.
实际上这个CMakeList文件的编写者是在ubuntu系linux下测试的,如果你使用ubuntu系的linux的话,安装好各种库之后就可以用cmake一键编译了,如果不是的话就往下看吧.
2.2 使用VisualStudio编译 我不太喜欢这个重量级的软件,如果想要用vs编译的话,建议去参考尸体233的Travis CI脚本,按照这个脚本一步步操作,可以生成sln项目文件,然后就能用vs编译了,下面的内容就可以直接跳过去了,直接去看第3节了.
2.3 使用vcpkg管理第三方库 如果你按照上面的操作使用vs编译的话,你需要下载一堆第三方库的源码,然后解压到指定目录,特别麻烦,而且这些库是"一次性"的,所以我推荐使用vcpkg去统一管理这些第三方库,具体使用方法我就不多说了,懂得都懂,官方文档.
我用的linux,自带包管理工具,也需要用vcpkg吗?
如果使用的是非ubuntu系的话,还是建议使用,因为vcpkg可以完美嵌入cmake,如果使用的是自带的包管理工具的话,可能cmake无法find到某个库,头文件路径也可能跟代码有出入,用了vcpkg,这一切就都解决了.
2.4 使用vscode 如果没有选择vs的话,vscode就是最佳选择了,话是这么说,但vs改装还得装,因为编译器msvc是必须的. 需要的vscode插件:C/C++ ,CMake 和CMake Tools.
关于CLion
我使用过一段时间的CLion,它的体验基本上跟vscode一致,但存在一些缺点:
占用资源比较大 多线程调试很差,甚至不如直接用gdb.(这是我遇到的问题,我没找到原因) 2.5 linux上使用cmake+gcc编译 如上面所说,使用vcpkg管理第三方库,嵌入项目自带的CMakeLists文件即可.
具体做法:将原本的第三方库相关内容去掉换成vcpkg
2.6 windows上使用cmake+msvc编译 杂项 游戏配置的读取 ygopro所有的游戏配置都写在文本文件里
lflist.conf 禁卡表文件,包含了所有的禁卡表 strings.conf 在客户端上显示的所有文字 system.conf 一些设置选项 irrlicht irrlicht是一个古老的游戏引擎,网上几乎没有什么中文资料,不过对于ygopro来说,只用了一些简单的图形效果和很复古的GUI,比如下面的程序通过改变卡片的横坐标来表示卡组的洗牌动画
for (auto cit = mainGame->dField.deck[player].begin(); cit != mainGame->dField.deck[player].end(); ++cit) { (*cit)->dPos = irr::core::vector3df(rnd.rand() * 0.4f / rnd.rand_max - 0.2f, 0, 0); (*cit)->dRot = irr::core::vector3df(0, 0, 0); (*cit)->is_moving = true; (*cit)->aniFrame = 3; } 想学习irrlicht的话建议去看官方的Tutorials.
irrlicht写的非常规范,容易阅读,但毕竟十几年前的产物了,并不推荐用这个制作游戏.
I 开头的是 纯虚接口类 C 开头的是 接口实现类 E 是枚举值 S 是结构体 irrlichtr是个3D引擎,想深入学习需要OpenGL或者Direct3D相关的知识.
但是对于ygopro来说,只需要了解下面这两点就可以了
1.irrlicht的初始化操作
首先需要获取一个IrrlichtDevice,这是irrlicht最根本的对象,有两种方法得到
自定义params,也是ygopro使用的方法 IrrlichtDevice* device; irr::SIrrlichtCreationParameters params = irr::SIrrlichtCreationParameters(); //对params做一些自定义 device = irr::createDeviceEx(params); 或者 使用默认params 函数原型: IrrlichtDevice* createDevice( video::E_DRIVER_TYPE deviceType = video::EDT_SOFTWARE, const core::dimension2d&lt;u32>&amp; windowSize = (core::dimension2d&lt;u32>(640,480)), u32 bits = 16, bool fullscreen = false, bool stencilbuffer = false, bool vsync = false, IEventReceiver* receiver = 0); 使用IrrlichtDevice获取其他对象
获取IVideoDriver,所有图形相关的接口 IVideoDriver* driver = device->getVideoDriver(); 获取IGUIEnvironment,用于管理所有GUI组件 IGUIEnvironment* env = device->getGUIEnvironment(); 获取ISceneManager,管理camera 等其他资源 ISceneManager* smgr = device->getSceneManager(); 主循环
while(device->run()) { //绘制GUI 绘制图形 //接收玩家输入等 } 2.GUI相关
irrlicht的GUI还是比较落后的.ygopro用了七八百行,来添加GUI元素
添加GUI的步骤
首先去要预先定义一些宏来表示GUI的id(类似QT里的信号),如: #define BUTTON_LAN_MODE 100 #define BUTTON_SINGLE_MODE 101 #define BUTTON_REPLAY_MODE 102 #define BUTTON_TEST_MODE 103 添加btn btnLanMode = env->addButton(rect&lt;s32>(10, 30, 270, 60), wMainMenu, BUTTON_LAN_MODE, dataManager.GetSysString(1200)); 添加checkbox chkHostPrepReady[i] = env->addCheckBox(false, rect&lt;s32>(250, 75 + i * 25, 270, 95 + i * 25), wHostPrepare, CHECKBOX_HP_READY, L""); 初始化这些元素时都有一个参数是id,当GUI元素被操作的时候这些id就代表了不同的信号. 如何使用GUI
需要一个对象来接受这些信号,从而使这些GUI元素发挥作用.在irrlicht里,这个对象被称为EventReceiver.
同一时刻,一个device只能有一个EventReceiver.
这行程序为device设置了一个EventReceiver device->setEventReceiver(&amp;menuHandler); 任意一个类,只要重写了OnEvent(const irr::SEvent&amp; event)方法,就可以成为EventReceiver
声明 class MenuHandler: public irr::IEventReceiver { public: virtual bool OnEvent(const irr::SEvent&amp; event); }; 实现 bool MenuHandler::OnEvent(const irr::SEvent&amp; event) { switch(event.EventType){ //获取event类型 case irr::EET_GUI_EVENT: //GUI事件 //根据id判断是哪个GUI元素,然后做出相应操作 s32 id = event.GUIEvent.Caller->getID(); case irr::EET_MOUSE_INPUT_EVENT: //鼠标输入事件 case irr::EET_KEY_INPUT_EVENT: //键盘输入事件 //判断哪个健被按下 switch(event.KeyInput.Key) } } sqlite ygopro使用sqlite把所有卡片的信息存储在cards.cdb这个文件中.可以使用sqlitebrowser来方便的操作这个文件.
cards.cdb中有两个表,datas和texts datas的内容是卡片的信息(用数字表示),texts的内容是跟卡片有关的字符串.
datas的表头如下:
id ot alias setcode type atk def level race attribute category 需注意:这些数值的用途大部分是在卡组构造界面搜索卡片
id :表示卡片的官方代码 ot :表示卡片的限制情况 0代表禁止 3代表无限制 alias:表示别名,有些卡片被科乐美复刻了多次,比如青眼白龙,复刻后的青眼白龙的alias就是初版青眼白龙的id setcode :一个10进制数,表示卡片所属的字段,把这个数转换成16进制可得到字段, 每个字段4位16进制数.strings.conf文件中存储了所有字段 举个例子:数据库中查到的setcode最大值的卡片是"希望皇 拟声乌托邦",所属字段是"刷拉拉(0x8f)" &ldquo;我我我(0x54)&rdquo; &ldquo;隆隆隆(0x59)&rdquo; &ldquo;怒怒怒(0x82)",这张卡片的setcode是36592129229979791, 转换成16进制是82 0059 0054 008F
type :一个10进制数,转换成2进制后,表示卡片类型. atk :攻击力 def:防御力 level: 等级 or 阶级 or link值 race:种族 attribute:属性 category:一个10进制数,转换成32bit的二进制数,恰好对应卡片搜索的中的32个效果. 举个例子:随机选择了一张卡"暗之支配者-佐克&rdquo;,其category值为134217730,写成二进制是00001000000000000000000000000010,倒着看,恰好对应第二个效果"怪兽破坏"和倒数第五个效果"幸运",
至于为什么要倒着看,因为代码中是通过下面的方式设置过滤选项的
long long filter = 0x1; for(int i = 0; i &lt; 32; ++i, filter &lt;&lt;= 1) if(mainGame->chkCategory[i]->isChecked()) filter_effect |= filter; texts的内容比较简单 就不展开了.
网络部分 当一个玩家点击"新建主机"时,会同时建立一个server和client,server会立即开始监听,然后client会立即连接server,当另一个玩家点击加入游戏时,会建立一个client按照地址和端口去连接server.
当server接收到client的连接后,会新建一个bufferevent建立与client之间的连接
非TAG模式下,第三个以上的玩家再加入游戏就会变成观众.
client给server发送数据 这个操作重载了3个函数
static void SendPacketToServer(unsigned char proto); template&lt;typename ST> static void SendPacketToServer(unsigned char proto, ST&amp; st); static void SendBufferToServer(unsigned char proto, void* buffer, size_t len); 实际上发送的数据有一个固定的格式
16bit 8bit 若干附加内容 1+附加内容的字节数 proto server接收到数据后 首先会根据数据的前两个字节(packet_len)来判断数据数否正确
if(len &lt; 2) return; evbuffer_copyout(input, &amp;packet_len, 2); //将数据的前两位 (包的长度) 复制到 packet_len if(len &lt; (size_t)packet_len + 2) return; 然后跳过表示packet_len的前两个字节,从第三个字节开始处理
void NetServer::HandleCTOSPacket(DuelPlayer* dp, char* data, unsigned int len); HandleCTOSPacket函数会根据不同的proto来做出不同的反应,处理过之后会通过下一节的函数来给玩家和观战者发送数据
server给client发送数据 同样重载了3个函数
static void SendPacketToPlayer(DuelPlayer* dp, unsigned char proto); template&lt;typename ST> static void SendPacketToPlayer(DuelPlayer* dp, unsigned char proto, ST&amp; st) static void SendBufferToPlayer(DuelPlayer* dp, unsigned char proto, void* buffer, size_t len); 发送数据的格式和上文一致
这个函数执行完之后通常需要立即执行
static void ReSendToPlayer(DuelPlayer* dp); 给另一个玩家以及观战者发送相同的数据
client接收到数据后 和server类似,client首先会根据数据的前两个字节(packet_len)来判断数据数否正确
if(len &lt; 2) return; evbuffer_copyout(input, &amp;packet_len, 2); if(len &lt; (size_t)packet_len + 2) return; 然后跳过表示packet_len的前两个字节,从第三个字节开始处理
void DuelClient::HandleSTOCPacketLan(char* data, unsigned int len); HandleSTOCPacketLan函数会通过不同的proto进行让client做出不同的操作</content></entry><entry><title>关于我</title><url>http://rayrain.xyz/about.html</url><categories/><tags/><content type="html"> a righteoux</content></entry><entry><title>Markdown语法手册</title><url>http://rayrain.xyz/markdown-syntax/</url><categories><category>themes</category><category>syntax</category></categories><tags><tag>markdown</tag><tag>css</tag><tag>html</tag></tags><content type="html"> 本文提供了一个可以在 Hugo 内容文件中使用的基本Markdown语法示例，还展示了基本 HTML 元素在 Hugo 主题中是否使用 CSS 装饰。
标题 下面的 HTML 代码&lt;h1>—&lt;h6> 元素表示六个级别的节标题。 &lt;h1>是最高的节级别，&lt;h6>是最低的节级别。
H1 H2 H3 H4 H5 H6 段落 Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.
伊塔图？厨房里有很多东西，我不知道他们喜欢吃什么，或者他们喜欢吃什么。
引用 blockquote元素表示从另一个来源引用的内容，可选的引用必须在footer或cite元素内，也可选的内嵌更改，如注释和缩写。
引用没有归属 Tiam, ad mint andaepu dandae nostion secatur sequo quae. 注意 可以在块引用中使用 Markdown 语法。
带归属的引用 不要通过分享记忆来交流，通过交流来分享记忆。
— 罗布·派克1
表格 表不是Markdown核心规范的一部分，但是Hugo支持开箱即用。
Name Age Bob 27 Alice 23 表格内使用Markdown语法 Italics Bold Code italics bold code 图像 ![图像描述](图像地址) 示例 Google Chrome Firefox Browser
点击图像可以打开图像浏览器，快试试吧。
代码块 带有引号的代码块 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 用四个空格缩进的代码块 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 代码块引用Hugo的内部高亮短代码 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 列表类型 有序列表 First item Second item Third item 无序列表 List item Another item And another item 嵌套列表 Fruit Apple Orange Banana Dairy Milk Cheese 其他元素 — abbr, sub, sup, kbd, mark GIF 是位图图像格式。
H2O
Xn + Yn = Zn
按 CTRL+ALT+Delete 组合键结束会话。
大多数蝾螈在夜间活动，捕食昆虫、蠕虫和其他小动物。
以上引文摘自Rob Pike在2015年11月18日Gopherfest上的演讲。&#160;&#8617;&#xfe0e;</content></entry><entry><title>占位符文本显示</title><url>http://rayrain.xyz/placeholder-text/</url><categories/><tags><tag>markdown</tag><tag>text</tag></tags><content type="html"> 你对我的心有偏见。我向您保证，我们的生活将不会受到影响，我们的生活将会受到影响。你说你现在住在医院里，因为你的眼睛是透明的，你的眼睛是光明的，你的眼睛是光明的!
Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.
Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt
The Van de Graaf Canon
Mane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.
Iubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.
Eurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.</content></entry><entry><title>数据公式设置显示</title><url>http://rayrain.xyz/math-typesetting/</url><categories/><tags/><content type="html"> Hugo项目中的数学表示法可以通过使用第三方JavaScript库来实现。
在这个例子中，我们将使用 MathJax
Create a post under /content/en[zh-CN]/math.md
可以全局启用MathJax，请在项目配置中将参数math设置为true
或是在每页基础上启用MathJax，在内容文件中包括参数math: true
注意： 使用支持的TeX功能的联机参考资料
例子 重复的分数 $$ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} \equiv 1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}} {1+\frac{e^{-8\pi}} {1+\cdots} } } } $$
总和记号 $$ \left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right) $$
几何级数之和 我把接下来的两个例子分成了几行，这样它在手机上表现得更好。这就是为什么它们包含 \displaystyle。
$$ \displaystyle\sum_{i=1}^{k+1}i $$
$$ \displaystyle= \left(\sum_{i=1}^{k}i\right) +(k+1) $$
$$ \displaystyle= \frac{k(k+1)}{2}+k+1 $$
$$ \displaystyle= \frac{k(k+1)+2(k+1)}{2} $$
$$ \displaystyle= \frac{(k+1)(k+2)}{2} $$
$$ \displaystyle= \frac{(k+1)((k+1)+1)}{2} $$
乘记号 $$ \displaystyle 1 + \frac{q^2}{(1-q)}+\frac{q^6}{(1-q)(1-q^2)}+\cdots = \displaystyle \prod_{j=0}^{\infty}\frac{1}{(1-q^{5j+2})(1-q^{5j+3})}, \displaystyle\text{ for }\lvert q\rvert &lt; 1. $$
随文数式 这是一些线性数学: $$ k_{n+1} = n^2 + k_n^2 - k_{n-1} $$ ， 然后是更多的文本。
希腊字母 $$ \Gamma\ \Delta\ \Theta\ \Lambda\ \Xi\ \Pi\ \Sigma\ \Upsilon\ \Phi\ \Psi\ \Omega \alpha\ \beta\ \gamma\ \delta\ \epsilon\ \zeta\ \eta\ \theta\ \iota\ \kappa\ \lambda\ \mu\ \nu\ \xi \ \omicron\ \pi\ \rho\ \sigma\ \tau\ \upsilon\ \phi\ \chi\ \psi\ \omega\ \varepsilon\ \vartheta\ \varpi\ \varrho\ \varsigma\ \varphi $$
箭头 $$ \gets\ \to\ \leftarrow\ \rightarrow\ \uparrow\ \Uparrow\ \downarrow\ \Downarrow\ \updownarrow\ \Updownarrow $$
$$ \Leftarrow\ \Rightarrow\ \leftrightarrow\ \Leftrightarrow\ \mapsto\ \hookleftarrow \leftharpoonup\ \leftharpoondown\ \rightleftharpoons\ \longleftarrow\ \Longleftarrow\ \longrightarrow $$
$$ \Longrightarrow\ \longleftrightarrow\ \Longleftrightarrow\ \longmapsto\ \hookrightarrow\ \rightharpoonup $$
$$ \rightharpoondown\ \leadsto\ \nearrow\ \searrow\ \swarrow\ \nwarrow $$
符号 $$ \surd\ \barwedge\ \veebar\ \odot\ \oplus\ \otimes\ \oslash\ \circledcirc\ \boxdot\ \bigtriangleup $$
$$ \bigtriangledown\ \dagger\ \diamond\ \star\ \triangleleft\ \triangleright\ \angle\ \infty\ \prime\ \triangle $$
微积分学 $$ \int u \frac{dv}{dx},dx=uv-\int \frac{du}{dx}v,dx $$
$$ f(x) = \int_{-\infty}^\infty \hat f(\xi),e^{2 \pi i \xi x} $$
$$ \oint \vec{F} \cdot d\vec{s}=0 $$
洛伦茨方程 $$ \begin{aligned} \dot{x} &amp; = \sigma(y-x) \ \dot{y} &amp; = \rho x - y - xz \ \dot{z} &amp; = -\beta z + xy \end{aligned} $$
交叉乘积 这在KaTeX中是可行的，但在这种环境中馏分的分离不是很好。
$$ \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \ \frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \ \frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \end{vmatrix} $$
这里有一个解决方案:使用“mfrac”类(在MathJax情况下没有区别)的额外类使分数更小:
$$ \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \ \frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \ \frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \end{vmatrix} $$
强调 $$ \hat{x}\ \vec{x}\ \ddot{x} $$
有弹性的括号 $$ \left(\frac{x^2}{y^3}\right) $$
评估范围 $$ \left.\frac{x^3}{3}\right|_0^1 $$
诊断标准 $$ f(n) = \begin{cases} \frac{n}{2}, &amp; \text{if } n\text{ is even} \ 3n+1, &amp; \text{if } n\text{ is odd} \end{cases} $$
麦克斯韦方程组 $$ \begin{aligned} \nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \ \nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \ \nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \ \nabla \cdot \vec{\mathbf{B}} &amp; = 0 \end{aligned} $$
这些方程式很狭窄。我们可以使用(例如)添加垂直间距 [1em] 在每个换行符(\)之后。正如你在这里看到的：
$$ \begin{aligned} \nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \[1em] \nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \[0.5em] \nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \[1em] \nabla \cdot \vec{\mathbf{B}} &amp; = 0 \end{aligned} $$
统计学 固定词组：
$$ \frac{n!}{k!(n-k)!} = {^n}C_k {n \choose k} $$
分数在分数 $$ \frac{\frac{1}{x}+\frac{1}{y}}{y-z} $$
ｎ次方根 $$ \sqrt[n]{1+x+x^2+x^3+\ldots} $$
矩阵 $$ \begin{pmatrix} a_{11} &amp; a_{12} &amp; a_{13}\ a_{21} &amp; a_{22} &amp; a_{23}\ a_{31} &amp; a_{32} &amp; a_{33} \end{pmatrix} \begin{bmatrix} 0 &amp; \cdots &amp; 0 \ \vdots &amp; \ddots &amp; \vdots \ 0 &amp; \cdots &amp; 0 \end{bmatrix} $$
标点符号 $$ f(x) = \sqrt{1+x} \quad (x \ge -1) f(x) \sim x^2 \quad (x\to\infty) $$
现在用标点符号:
$$ f(x) = \sqrt{1+x}, \quad x \ge -1 f(x) \sim x^2, \quad x\to\infty $$</content></entry><entry><title>支持Emoji表情符号</title><url>http://rayrain.xyz/emoji-support/</url><categories/><tags><tag>emoji</tag></tags><content type="html"> 在Hugo项目中可以通过多种方式启用Emoji。
The emojify function can be called directly in templates or Inline Shortcodes.
To enable emoji globally, set enableEmoji to true in your site&rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.
馃檲 🙈 馃檳 🙉 馃檴 🙊
The Emoji cheat sheet is a useful reference for emoji shorthand codes.
N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.
.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }</content></entry></search>