<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>VIM技巧(持续更新)</title><url>http://rayrain.xyz/post/vim/</url><categories/><tags><tag>vim</tag></tags><content type="html"> 简单记录一下vim的技巧
打开nerdtree 目录 命令行下:
vim ./ vim中:
:e %:h //打开当前文件所在目录 :e ./ //貌似这样也可以 在nerdtree目录下 s //默认打开一个垂直的分割窗口 t //打开一个新的tab窗口 操作tab page gt //默认移动到下一个tab 1gt //打开第一个tab 2gt //打开第二个tab 操作分割窗口 :sp //横向打开分割窗口 :vsp //垂直打开分割窗口 ctrl w + 方向键 //在分割窗口之间移动 内置grep搜索 :vim[grep][!] /{pattern}/[g][j] {file} ... :vim[grep][!] {pattern} {file} ... vimgrep可以简写为vim 举例
在当前目录下的linux-user文件夹下 的c文件中搜索 main( 字符串 :vimgrep main( ./linux-user/*.c 更多
:cnext, :cn # 当前页下一个结果 :cprevious, :cp # 当前页上一个结果 :clist, :cl # 使用 more 打开 Quickfix 窗口 :copen, :cope, :cw # 打开 Quickfix 窗口，列出所有结果 :ccl[ose] # 关闭 Quickfix 窗口。 lvimgrep 命令 lvimgrep 与 vimgrep 搜索命令基本一样，不同点在于搜索结果不是显示在 Quickfix 中而是显示在 location-list 中 移动 使用大括号在空行之间移动
Ctags使用 生成tags 数据库文件
ctags -R . //递归生成当前根目录的tags文件 vim可以自动匹配tags文件
使用:
ctrl + ] //跳转到定义处 ctrl + T //返回到跳转前的位置 ctrl + W + ] //分割当前窗口,并在新窗口中显示跳转到的定义 ctrl + O //返回之前的位置 :ts //列出所有匹配的标签 CScope使用 生成数据库文件
cscope -Rbq 在vim中:
cscope 命令:(以下都已:cs开头) add : 添加一个新的数据库 (Usage: add file|dir [pre-path] [flags]) find : 查询一个模式 (Usage: find a|c|d|e|f|g|i|s|t name) a: Find assignments to this symbol c: Find functions calling this function d: Find functions called by this function 查找被这个函数调用的函数 e: Find this egrep pattern f: Find this file 查找这个文件 g: Find this definition 查找定义 i: Find files #including this file 查找include了这个文件的所有文件 s: Find this C symbol 查找C符号 t: Find this text string 查找这个文本字符串 help : 显示此信息 (Usage: help) kill : 结束一个连接 (Usage: kill #) reset: 重置所有连接 (Usage: reset) show : 显示连接 (Usage: show) 正则表达式 全字搜索
/\&lt;word\></content></entry><entry><title>从ELF谈起</title><url>http://rayrain.xyz/post/elf/</url><categories/><tags><tag>elf</tag><tag>linux</tag></tags><content type="html"> 本文信息来源:
又是一期硬核内容：ELF文件格式
What&rsquo;s the difference of section and segment in ELF file format
ELF Sections &amp; Segments and Linux VMA Mappings
ELF简介 ELF全称 executable and linkable format 精灵
是一种linux下常用的可执行文件 对象 共享库的标准文件格式
还有许多其他可执行文件格式 PE Mach-O COFF COM
内核中处理elf相关代码参考: binfmt_elf.c
elf中的数据按照Segment(段)和Section(节)两个概念进行划分
ELF文件格式 ELF Header 架构 ABI版本等基础信息 program header table的位置和数量 section header table的位置和数量 Program header table 每个表项定义了一个segment 每个segment可包含多个section Section header table 每个表项定义了一个section readelf命令 可用readelf命令来展示elf文件的相关信息
用法如下:
用法：readelf &lt;选项> elf-文件 显示关于 ELF 格式文件内容的信息 Options are: -a --all Equivalent to: -h -l -S -s -r -d -V -A -I -h --file-header Display the ELF file header -l --program-headers Display the program headers --segments An alias for --program-headers -S --section-headers Display the sections' header --sections An alias for --section-headers -g --section-groups Display the section groups -t --section-details Display the section details -e --headers Equivalent to: -h -l -S 比如,使用readelf来查看date的信息
readelf -l /bin/date 输出
Elf 文件类型为 DYN (Position-Independent Executable file) Entry point 0x38c0 There are 13 program headers, starting at offset 64 程序头： Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align PHDR 0x0000000000000040 0x0000000000000040 0x0000000000000040 0x00000000000002d8 0x00000000000002d8 R 0x8 INTERP 0x0000000000000318 0x0000000000000318 0x0000000000000318 0x000000000000001c 0x000000000000001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x00000000000028a8 0x00000000000028a8 R 0x1000 LOAD 0x0000000000003000 0x0000000000003000 0x0000000000003000 0x0000000000010001 0x0000000000010001 R E 0x1000 LOAD 0x0000000000014000 0x0000000000014000 0x0000000000014000 0x0000000000005cf0 0x0000000000005cf0 R 0x1000 LOAD 0x0000000000019ff0 0x000000000001aff0 0x000000000001aff0 0x00000000000010b0 0x0000000000001268 RW 0x1000 DYNAMIC 0x000000000001ab98 0x000000000001bb98 0x000000000001bb98 0x00000000000001f0 0x00000000000001f0 RW 0x8 NOTE 0x0000000000000338 0x0000000000000338 0x0000000000000338 0x0000000000000040 0x0000000000000040 R 0x8 NOTE 0x0000000000000378 0x0000000000000378 0x0000000000000378 0x0000000000000044 0x0000000000000044 R 0x4 GNU_PROPERTY 0x0000000000000338 0x0000000000000338 0x0000000000000338 0x0000000000000040 0x0000000000000040 R 0x8 GNU_EH_FRAME 0x0000000000018000 0x0000000000018000 0x0000000000018000 0x0000000000000454 0x0000000000000454 R 0x4 GNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 RW 0x10 GNU_RELRO 0x0000000000019ff0 0x000000000001aff0 0x000000000001aff0 0x0000000000001010 0x0000000000001010 R 0x1 Section to Segment mapping: 段节... 00 01 .interp 02 .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 03 .init .plt .text .fini 04 .rodata .eh_frame_hdr .eh_frame 05 .init_array .fini_array .data.rel.ro .dynamic .got .data .bss 06 .dynamic 07 .note.gnu.property 08 .note.gnu.build-id .note.ABI-tag 09 .note.gnu.property 10 .eh_frame_hdr 11 12 .init_array .fini_array .data.rel.ro .dynamic .got 可知:
在加载到内存中时,程序被分成了13个Segment(从PHDR到GNU_RELRO) 每个Segment都包含了1个或者更多的Section Segment vs Section Segment 包含着运行时需要的信息
用于告诉操作系统,段应该被加载到虚拟内存中的什么位置?每个段都有那些权限?(read, write, execute)
每个Segment主要包含加载地址 文件中的范围 内存权限 对齐方式等信息
Section 包含着链接时需要的信息
用于告诉链接器,elf中每个部分是什么,哪里是代码,哪里是只读数据,哪里是重定位信息
每个Section主要包含Section类型 文件中的位置 大小等信息
链接器会把Section放入Segment中
Segment和Section的关系 相同权限的Section会放入同一个Segment,例如.text和.rodata section 一个Segment包含许多Section,一个Section可以属于多个Segment 链接脚本 运行
ld --verbose 可以看到本系统中所用的脚本
我的Archlinux 5.16.13-arch1-1的链接脚本一部分是这样:
.gnu.version_r : { *(.gnu.version_r) } .rela.dyn : { *(.rela.init) *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) *(.rela.fini) *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) *(.rela.ctors) *(.rela.dtors) *(.rela.got) *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*) *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*) *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*) *(.rela.ifunc) } 表示:
.gnu.version_r Section 会被放入 .gnu.version_r Segment
.rela.init等一大堆的Section,会被放入 .rela.dyn Segment
汇编中的伪指令全部都是Section,要等链接之后才会有Segment
NASM中 .section 和.segment 这两个是等效的,都表示 Section
ELF文件分类 可执行文件(ET_EXEC) 可直接运行的程序,必须包含segment
对象文件(ET_REL,*.o) 需要与其他对象文件链接,必须包含section
动态库(ET_DYN,*.so) 与其他对象文件/可执行文件链接
必须同时包含segment和section
ELF的内存映射 查看内存映射情况 cat /proc/[pid]/maps 比如运行
cat /proc/self/maps 查看cat本身的内存映射
563b04d75000-563b04d77000 r--p 00000000 fe:00 6294104 /usr/bin/cat 563b04d77000-563b04d7c000 r-xp 00002000 fe:00 6294104 /usr/bin/cat 563b04d7c000-563b04d7f000 r--p 00007000 fe:00 6294104 /usr/bin/cat 563b04d7f000-563b04d80000 r--p 00009000 fe:00 6294104 /usr/bin/cat 563b04d80000-563b04d81000 rw-p 0000a000 fe:00 6294104 /usr/bin/cat 563b058b6000-563b058d7000 rw-p 00000000 00:00 0 [heap] 7f5f7324b000-7f5f73837000 r--p 00000000 fe:00 6364075 /usr/lib/locale/locale-archive 7f5f73837000-7f5f7383a000 rw-p 00000000 00:00 0 7f5f7383a000-7f5f73866000 r--p 00000000 fe:00 6294921 /usr/lib/libc.so.6 7f5f73866000-7f5f739dc000 r-xp 0002c000 fe:00 6294921 /usr/lib/libc.so.6 7f5f739dc000-7f5f73a30000 r--p 001a2000 fe:00 6294921 /usr/lib/libc.so.6 7f5f73a30000-7f5f73a31000 ---p 001f6000 fe:00 6294921 /usr/lib/libc.so.6 7f5f73a31000-7f5f73a34000 r--p 001f6000 fe:00 6294921 /usr/lib/libc.so.6 7f5f73a34000-7f5f73a37000 rw-p 001f9000 fe:00 6294921 /usr/lib/libc.so.6 7f5f73a37000-7f5f73a46000 rw-p 00000000 00:00 0 7f5f73a70000-7f5f73a92000 rw-p 00000000 00:00 0 7f5f73a92000-7f5f73a94000 r--p 00000000 fe:00 6294911 /usr/lib/ld-linux-x86-64.so.2 7f5f73a94000-7f5f73abb000 r-xp 00002000 fe:00 6294911 /usr/lib/ld-linux-x86-64.so.2 7f5f73abb000-7f5f73ac6000 r--p 00029000 fe:00 6294911 /usr/lib/ld-linux-x86-64.so.2 7f5f73ac7000-7f5f73ac9000 r--p 00034000 fe:00 6294911 /usr/lib/ld-linux-x86-64.so.2 7f5f73ac9000-7f5f73acb000 rw-p 00036000 fe:00 6294911 /usr/lib/ld-linux-x86-64.so.2 7ffec90a6000-7ffec90c8000 rw-p 00000000 00:00 0 [stack] 7ffec918d000-7ffec9191000 r--p 00000000 00:00 0 [vvar] 7ffec9191000-7ffec9193000 r-xp 00000000 00:00 0 [vdso] ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0 [vsyscall] 从左到右为:
虚拟地址的起始和结束 该内存映射的类型flag r(read) w(write) x(execute) p(private) s(shared) 实际对象在该内存映射上相对于起始的偏移量 major:minor: the major and minor number pairs of the device holding the file that has been mapped. 映射文件的索引节点号码 该内存映射文件的名称</content></entry><entry><title>转载自知乎</title><url>http://rayrain.xyz/xuzhou/</url><categories/><tags><tag>批话</tag></tags><content type="html"> 徐州调查报告不出所料地在深夜出炉时，有人这么评价：有关方面以为大家都睡了，其实大家都醒着。在这里我要替有关方面说一句：其实人家知道你们没睡，就是不想让你们睡。不睡觉伤身体，像你们这种恶意不睡的人，累死一个少一个，这是一盘大棋。
有些人表示不信这个报告，对此我要表示：还在谈论信不信的人，本身就是不幸的，因为你们还没有明白自己的身份。多少年了，有关方面什么时候在乎过你信不信？人家是演戏的，你却不是看戏的，你就是掏钱买票的。准确地说，都不用你掏，票钱早就从你钱袋里按月扣除了。戏都不是演给你看的，你鼓不鼓掌，重要吗？老老实实呢，还让你在台下待着，再不老实就换个地方让你待，票钱可不退。
再说了，鼓掌的有的是。用哈姆雷特的话来说：他们“可以怀疑真理是谎言，但对有关方面的爱永不变”。这是一切调查报告的基础，可以追溯到这类报告的老祖宗——《湖南农民运动考察报告》。
因此，徐州报告本身事没有问题的，问题在于有些人没读懂。别人不懂，我来懂，而且要旗帜鲜明地懂。借用一句著名的句式：细读吧，细读个十年八年，中国的一切都懂了！
本着“讲好中国故事”的追求，我们不光要鼓掌，还要讲清楚为什么鼓掌。也就是说，我要把这一报告隐含着的逻辑线索清理一遍。我觉得这样很欢乐，借用茨威格的句式：喜欢鼓掌的人是幸福的。
首先，有人认为有关方面对徐州事件不重视，理由是很多天没有官媒发言，甚至有人责难“妇联哪里去了？”从表面看，好像是这样。例如我翻看了一下中国妇联机关报《中国妇女报》的官方微博，确实一直没有提到此事，PIAPIA地全是铿锵玫瑰，置顶一条是“你永远可以相信中国姑娘”。
然而，这种情况并不能说明有关方面不重视，恰恰相反，说明有关方面很重视。这是我们应该明白的**第一条逻辑：在中国，一个事件的重要性，有时候不是体现在大家都在说，而是体现在大家都不说。**甚至越是重要的事大家越不说，连发生这些事情的日子都不提，就好像那一年、那一天不存在一样。
具体到徐州事件，不说，是为了正确地说。事实上，等深夜报告一出炉，《中国妇女报》官微第一时间就转发了。这说明有关方面毕竟不同于普通群众，他们是明真相的，是认真的。
按照有关方面的认真风格，他们一定对整个事件进行了充分评估，因此不难得出如下结论：该事件的最大罪恶，不是一个女人的一生被毁掉了，而是一个女人的一生被毁掉了这件事情，伤害了人们的幸福感。
用王小波的话来说，对有关方面而言，这位狗链八孩女，不应该被看作一个人，而应该被看作一件事，一件需要解决的事。这是我们应该明白的**第二条逻辑：人是不重要的，事才重要。**有时候看上去是解决了一个人，其实是解决了一件事。
所以我们都应该有这个自觉性：千万不要成为有关方面眼中的一件事，尤其是有害之事。
八孩女就是一件有害之事，它（不是“她”，因为已经不是人了）的有害之处在于：发生在一个幸福的国度。
换句话说，此事本该发生在漂亮国，那样就合情合理了。
然而它却不幸在世界上最幸福的地方发生了。此事难以否认，或者准确地说，已经错过了否认的最佳时机（这不得不说是事件初期的一个工作失误）。反漂亮理论家周小平同志这次也发挥失常，没能证明此事是漂亮国的阴谋。胡锡进老师最近的立场也不像退休之前那么坚定了，没有第一时间站出来领喊“今夜我们都是董某民”。
当然，有关方面还是从不同角度做了一些必要的工作，例如发炎人已经雄辩地证明了这种事在漂亮国很多。但显然，这只是侧面的工作。
另外还有一些外围工作，例如有关方面第一时间高效管控了事发地和外界的线下联络（这句话翻译一下就是村子已经被包围，外地人进不去了），再例如在当地大力弘扬“五种风气”，乃至大力宣传中国女足中的徐州籍队员（这朵铿锵玫瑰简直是徐州的天降及时花）等等。
但工作的核心，还是要落实到“修补人们的幸福感”这一重点上来。
很显然，要证明一个精神失常、满口没牙、戴着狗链生了八个孩子的女人是幸福的，难度实在太大。但我们说了，她不是一个人，而是一件事。作为一件事，她是否幸福不重要，重要的是不能让大家从她的命运联想到自己的命运。
而这种联想有个接口，就是拐卖。
如果没有拐卖这个话题，八孩女的惨剧就是个个案，顶多就是全民脱贫漏掉了一个。这都算不上一个指头和九个指头的问题，而是一根菜叶和十四亿根菜叶的问题。李毅博士大可以说“十四亿里有一个栓上狗链，等于一个都没拴。”
但有了拐卖话题，事情就危险了。尤其是恶意联想延伸开来，大家发现在幸福之邦的大白天完全有可能被一闷棍打昏，醒来就拴上狗链了。而且大家还发现徐州的狗链文化源远流长，甚至已经出现了整村暴露的苗头。这怎么行，徐州也是幸福之邦的一部分嘛！
这就是我们应该明白的**第三条逻辑：你的幸福不容质疑！**如果你质疑了，那你就成为了一件需要解决的事。神州大地没有悲剧，既然半年前的郑州没有，半年后的徐州也不该有。
所以，第一次官方通报就妥妥地确立了两个基本点：第一，她有精神病；第二，不存在拐卖。
有些人在嘲笑第一次通报，其实这次通报已经体现出了有关方面抓主要矛盾和矛盾的主要方面的清晰逻辑，准确地把握住了整件事的脉搏：第一点解释了狗链子，第二点切断了联想途径。根据这个通报，结论就是一个女疯子过得比较惨。但这和别人没关系嘛。
因此，作为第三条逻辑的自然延伸，**第四条逻辑是：在这次事件中，没有拐卖，因此没有伤害。**我们会发现，这条逻辑贯穿整个事件的始终。
如果不是有些恶意不睡觉的人没完没了，这件事本来已经圆满解决了。后来事情有了本不该有的后续发展，但并不能说明有关方面的工作做得不好。
第二份通报，要着重解决的是八孩女的来历问题。有关方面给出了一个充满想象空间的答案：她是在流浪的时候被董家收养的。同时强调：“调查中也未发现有拐卖行为”，这说明有关方面的逻辑线索一直是清晰的。
这份通报还有一些值得欣赏之处。例如表明董某民用狗链子锁人涉嫌违法，这能在一定程度上弱化事件中最有震撼力的画面产生的效应。再例如一个很有创造性的说法：“因为身体原因节育失效”。不光有创造性，还有前瞻性，如果有人追问“为什么失效了八次”，就可以说后四次是“因为心理原因节育失效”。
但这份通报最大的亮点还在于设定了那次收养行为的经办人：董某民他爹。之所以是亮点，是因为该爹已经死了。那些恶意不睡觉的人但凡还有一点良知，就应该到此为止了，因为总不能要求有关方面去找死人办案。
然而又有人抛出了一个四川籍的被拐的李姓女子，而且照片看上去是真像，而且和八孩女的疑似四川口音对上了。有了这些不利情况，于是第三份通报不得不面世。
有些人在嘲笑三份通报的前后不一致，但他们不明白，这恰恰是一条行之已久的逻辑。有关方面的哲学基础是辩证唯物主义，要以发展变化的眼光看问题。我们不能第二次踏进同一条河流去摸石头，所以每次踏进去的时候都要假装以前没踏过。
因此，如果我们看见十年前、五年前、一年前或者一天前的文件和今天说的完全不一样，应该懂得这是完全符合逻辑的。这是我们应该知道的**第五条逻辑：一切文件都是历史文件。**它们随时可能无效。
例如新领导上了台，老领导就成了历史，有关方面从来不会去解释老领导的指示为什么无效了，那些指示就像从来没有存在过一样。同理，一份新报告出台，旧报告就成了历史，相当于从来没有存在过。因此，如果以“前后不一致”为理由去嘲笑有关方面，反而会遭到他们的嘲笑。
第三份报告需要满足如下条件：一、为“疑似四川口音”提供解释；二、在第一点的基础上解释她为什么会出现在徐州；三、在第二点的基础上坚持“没有拐卖”的逻辑。
结果几乎完美，所有条件都没满足了。疑似四川口音是因为她是云南人（所以现在可以叫她“小花梅”了），到徐州是因为同村一个叫桑XX的带她去“找个好人家嫁了”，然后她走失了，所以仍然不是拐卖。
我用了“几乎”二字，是因为桑XX不像董某民他爹是个死人。虽然坚持原说法对她最有利，但她还是有可能成为一个BUG。如果那样，她就不再是一个人，而会成为一件事了。
另外还有点小瑕疵，例如“牙齿脱落因重症牙周病所致”，这个简单的原因花了这么久才找到，该给差评。“其他健康指标正常”，应该强调“包括脖子”。
但这份通告有一个最大的亮点：体现出一种和舆情博弈的柔性。它传递出如下含义：好吧，我们已经承认她是云南的了，那你们也该退一步，不要再坚持说她是四川的了吧！
这场博弈进行下去，“小花梅”的原籍很可能从中缅边境迁移到川滇边境，止于昭通或者西昌。当然，那时候她可能就不叫小花梅了。
在这里我们可以发现**第六条逻辑：有关方面可以作出调整，但你们也必须付出代价。**这种逻辑已经体现过很多次，例如你们的述求可以答应，但领头的必须抓起来。
我们说过，有关方面其实并不在乎舆情，他只管说，至于你信不信不在他们的考虑之内。很多话他们说的时候就知道你不信，但如果每句话都要人信，那工作还做不做了？
这里就有了**第七条逻辑：有关方面追求的不是你信，而是自洽。**换句话说，他们只需要在他们自己的封闭体系内获得认可。如果要说得再明白点，他们的表演不是给观众看的，而是给导演看的。
事实上，八孩女是不是四川的，这本身并不重要。但既然你们先发现了她是四川的，那有关方面只好不认了。甚至是否存在拐卖，这本身也不重要。如果是有关方面自己发现，因此破获了一起埋藏多年的拐卖大案，解救被害妇女于水火之中，那是值得大书特书的，《中国妇女报》也决不惮于第一时间分出一些铿锵玫瑰的版面来歌颂的。这并不会损害人们的幸福感，反而会强化它。
但问题就在于，这些事应该由有关方面自己去发现，如果他们暂时不能发现，大家就该耐心等待，而不能自己去发现。因为一旦大家养成了自己发现的习惯，就可能发现一些不该发现的事情。这是个原则问题，马虎不得。
因此，我们应该知道的最后一条，也是最重要的一条逻辑是：发现是有关方面神圣不可侵犯的权力。
我们可以这样理解：发现，就好比石油、烟草、电力和电信，是有关方面的专营领域。
当说到有关方面的权力的时候，大家都知道枪杆子刀把子笔杆子钱袋子，其实还应该加上一样：眼珠子。让你看的你就看，不让你看的就别看。
革命现代京剧（也就是传说中的样板戏）看来是确有复兴的必要了。例如，《沙家浜》里有句名言就应该大力推广：这个队伍谁当家？！
以上就是徐州报告给我们的启发。一份报告能给我们如此多的教益，我们除了旗帜鲜明地表示懂了，不作他想。
也许，半年之后，我们会看到又一份调查报告：徐州有关方面风险意识不强、认识准备不足、防范组织不力、应急处置不当，存在失职渎职行为，N名公职人员被问责。但那已经是更高的有关方面高度重视、深入调查、严肃处理的结果，跟别人无关了。
很可能，那时我们已经把这件事忘掉了。</content></entry><entry><title>hspro随记</title><url>http://rayrain.xyz/hspro_note/</url><categories/><tags><tag>ygopro</tag><tag>未整理</tag><tag>hspro</tag></tags><content type="html"> 我特别喜欢高桥和希的&lt;游戏王>这部作品,这部作品非常精彩,初代漫画我看了起码有10遍了.
所以在我第一次接触到炉石传说时,我已经玩了2年的ygopro了;
btw,ygopro最开始的名字其实是这个:ygocore
从我第一次玩到炉石传说的时候,我就想着能不能有一个类似ygopro的软件来模拟炉石传说.但这显然是不可能的.因为Yu-Gi-Oh是科乐美发行的实体纸牌游戏,ygopro并不会直接影响到科乐美卖纸牌,相反,ygopro还能为Yu-Gi-Oh免费宣传.
但炉石传说就不一样了,炉石传说的世界里充满了随机,只能是一个TCG网络游戏,如果谁要开个免费的私服,那属于是侵权行为了.
但是还真有人去做这个事情了,HearthSim直球叫"炉石传说模拟器",C#做的,已经停更有一段时间了. 画风是这样的 在中文社区,玩家们更喜欢的是DIY卡片,比如这张&lt;睿智杀手蟹>经常在各路DIY的帖子下面出现.
于是我就萌生了制作"针对于DIY玩家的炉石模拟器"的想法.
因为Yu-Gi-Oh要远远比炉石传说复杂,我决定基于ygopro来制作.出于对ygopro的致敬,这个项目名为 hspro
hspro 的目标:
脚本决定一切 卡片 关键字 规则 技能都由脚本决定
局域网联机对战 卡片编号</content></entry><entry><title>ocgcore随记</title><url>http://rayrain.xyz/ocgcore_note/</url><categories/><tags><tag>ygopro</tag><tag>未整理</tag></tags><content type="html"> ocgcore的几个模块 interpreter 负责处理lua的一切事务 运行lua函数
管理了一个协程映射,&lt;func_ref,luas_tate>
注册卡片 注册效果 注册卡片组 等等到lua注册表里面
函数 函数的存在形式 函数主要是指的是 卡片脚本中自定义的函数. condition target cost operation等.
当运行interpreter::register_card时,
会运行每个脚本特有的initial_effect函数,将condition target cost operation等函数注册到注册表里,
并把相应的ref值交给effect保管
这些函数如何运行 这些函数是通过协程运行的,调用call_coroutine函数.
函数的参数 传入参数存储在
std::list&lt;std::pair&lt;void*, uint32>> params 中,
其中frist是参数,因为要传入lua,所以用void*表示
second是参数的类型.
#define PARAM_TYPE_INT 0x01 #define PARAM_TYPE_STRING 0x02 #define PARAM_TYPE_CARD 0x04 #define PARAM_TYPE_GROUP 0x08 #define PARAM_TYPE_EFFECT 0x10 #define PARAM_TYPE_FUNCTION 0x20 #define PARAM_TYPE_BOOLEAN 0x40 #define PARAM_TYPE_INDEX 0x80 process field::process()的作用是处理一个单元块step,返回bufferlen
extern "C" DECL_DLLEXPORT int32 process调用上者,如果没有返回值,就一致循环的调用,如果有返回值,就停止循环,交给ygopro处理.
ygopro会一直持续的交替运行 process SinglePlayAnalyze</content></entry><entry><title>ygopro源码分析2:lua的使用</title><url>http://rayrain.xyz/ygopro2/</url><categories/><tags><tag>ygopro</tag></tags><content type="html"> lua简介 lua是一门嵌入式的脚本语言,其存在的意义就是给C/C++等高级语言打下手,当一个好配角.
对于C/C++来说,lua的作用主要体现在:在C/C++程序没有重新编译,甚至没有重启的情况下,只通过改变lua脚本的内容,令C/C++程序做出不一样的行为,本文中以C语言为例.
一些有用的链接,全部啃完就能成为lua中级高手了.
lua菜鸟教程
lua5.3官方手册
lua程序设计
ygopro卡片脚本编写教程
只是窥探ocgcore的究竟的话,没必要啃那么多, 下面会讲解一些阅读ocgcore代码所需要用到的lua技能.
准备 需要有一个lua5.3的命令行程序,也就是上一篇文章中被删掉了luac.c文件.可以去官网直接下载,也可以再开个工程连同luac.c编译一遍.记得exe文件要放进环境变量PATH里面.
vscode下载lua相关插件
创建一个cmake工程,使用上一篇文章的方法 通过cmake编译lua库,然后连接到我们将要编写的c程序.
lua语法 lua的语法特别简单,首先建议阅读"lua菜鸟教程",不用全部读完,把变量 函数 分支循环 这些编程语言共有的内容都读完就可以了.大概半小时内就可以完成.
table表 table是lua中最重要的类型,什么都能存放,键值对,套娃就不多说了,大部分教程已经说的很清楚了.
最重要的是,它还能存放函数,但函数实际上就是一些字符串而已,一个table存放一些函数名 和 存放一些字符串 这两个行为,是一样的.唯一区别就是 lua的全局空间里已经提前注册好了相关函数
元表和元方法 元表首先是一个表,但它孤立存在没有意义,它需要"挂"在另一个表上当"工具人",才能成为元表.
--把metatable设置成table的元表 我们称table是主表 setmetatable(table,metatable) 如果元表只是当"挂件"的话,也同样没有意义,既然是"工具人"那肯定得有一些特殊的功能/函数.
元表的作用:当主表进行了某些未定义的操作时,主表会让元表站出来帮它完成这些操作.
实际上这些"未定义的操作",lua官方已经为我们定义好了一堆key来对应那些未定义的操作,我们让相应的key对应自定义的函数
这样当主表进行了某些未定义的操作时,就会调用相应key的对应函数,这些函数就是元方法.
table = {} --将要成为主表 metatable = {} --将要成为元表 indextable = {value = 10} --设置索引专用表 setmetatable(table,metatable) --设置metatable作为table的元表 --index 操作(指查询主表中不存在的元素) metatable.__index = indextable print(table.value) --输出结果:10 当查询table里不存在的元素时,就会去__index指向的indextable寻找
--add元方法 metatable.__add = function (op1,op2) print("this is add!") return "return 'add'" end print(table + table) --输出结果: this is add! return 'add' C API 更多时候lua是作为一个库来使用的,命令行程序luac只是lua库的副产物,其核心是使用了lua_pcall函数,一共只有400多行.
lua可以嵌入到C程序里,但lua和C是两个完全不一样的世界,lua中的变量只能由lua管理,C语言中的值lua也不知道,双方只能通过一个虚拟栈来交换信息.C和lua之间也主要是围绕着"lua虚拟栈" &ldquo;lua环境&rdquo; &ldquo;C环境&rdquo; 编程的.
创建一个lua对象 lua_State *L = luaL_newstate(); 虚拟栈 lua虚拟栈是这样的--> | 栈顶 | 索引值:-1 -------- | | ------- | 栈底 | 索引值:1 ------- 和一般的栈没有什么不同 push类函数 C &ndash;> stack 这类函数的作用是:将C中生成的变量入栈
LUA_API void (lua_pushnil) (lua_State *L); LUA_API void (lua_pushnumber) (lua_State *L, lua_Number n); LUA_API void (lua_pushinteger) (lua_State *L, lua_Integer n); LUA_API const char *(lua_pushlstring) (lua_State *L, const char *s, size_t len); LUA_API const char *(lua_pushstring) (lua_State *L, const char *s); LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt, va_list argp); LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...); LUA_API void (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n); LUA_API void (lua_pushboolean) (lua_State *L, int b); LUA_API void (lua_pushlightuserdata) (lua_State *L, void *p); LUA_API int (lua_pushthread) (lua_State *L); set类函数 stack &ndash;> lua 这类函数的作用是:弹出栈顶的元素,然后将其设置为其他变量的某值
LUA_API void (lua_setglobal) (lua_State *L, const char *name); LUA_API void (lua_settable) (lua_State *L, int idx); LUA_API void (lua_setfield) (lua_State *L, int idx, const char *k); LUA_API void (lua_seti) (lua_State *L, int idx, lua_Integer n); LUA_API void (lua_rawset) (lua_State *L, int idx); LUA_API void (lua_rawseti) (lua_State *L, int idx, lua_Integer n); LUA_API void (lua_rawsetp) (lua_State *L, int idx, const void *p); LUA_API int (lua_setmetatable) (lua_State *L, int objindex); LUA_API void (lua_setuservalue) (lua_State *L, int idx); get类函数 lua &ndash;> stack 这类函数的作用是:将lua环境中存在的变量放入栈顶
LUA_API int (lua_getglobal) (lua_State *L, const char *name); LUA_API int (lua_gettable) (lua_State *L, int idx); LUA_API int (lua_getfield) (lua_State *L, int idx, const char *k); LUA_API int (lua_geti) (lua_State *L, int idx, lua_Integer n); LUA_API int (lua_rawget) (lua_State *L, int idx); LUA_API int (lua_rawgeti) (lua_State *L, int idx, lua_Integer n); LUA_API int (lua_rawgetp) (lua_State *L, int idx, const void *p); LUA_API void (lua_createtable) (lua_State *L, int narr, int nrec); LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz); LUA_API int (lua_getmetatable) (lua_State *L, int objindex); LUA_API int (lua_getuservalue) (lua_State *L, int idx); access类函数 stack &ndash;> C 这类函数的作用是:检查栈中的元素,将结果传入C环境中.或者直接将栈中的元素读到C环境中,这个操作不会影响栈
LUA_API int (lua_isnumber) (lua_State *L, int idx); LUA_API int (lua_isstring) (lua_State *L, int idx); LUA_API int (lua_iscfunction) (lua_State *L, int idx); LUA_API int (lua_isinteger) (lua_State *L, int idx); LUA_API int (lua_isuserdata) (lua_State *L, int idx); LUA_API int (lua_type) (lua_State *L, int idx); LUA_API const char *(lua_typename) (lua_State *L, int tp); LUA_API lua_Number (lua_tonumberx) (lua_State *L, int idx, int *isnum); LUA_API lua_Integer (lua_tointegerx) (lua_State *L, int idx, int *isnum); LUA_API int (lua_toboolean) (lua_State *L, int idx); LUA_API const char *(lua_tolstring) (lua_State *L, int idx, size_t *len); LUA_API size_t (lua_rawlen) (lua_State *L, int idx); LUA_API lua_CFunction (lua_tocfunction) (lua_State *L, int idx); LUA_API void *(lua_touserdata) (lua_State *L, int idx); LUA_API lua_State *(lua_tothread) (lua_State *L, int idx); LUA_API const void *(lua_topointer) (lua_State *L, int idx); load&amp;call类函数 这类函数的主要作用就是读取lua代码或者执行lua函数
LUA_API void (lua_callk) (lua_State *L, int nargs, int nresults, lua_KContext ctx, lua_KFunction k); #define lua_call(L,n,r) lua_callk(L, (n), (r), 0, NULL) LUA_API int (lua_pcallk) (lua_State *L, int nargs, int nresults, int errfunc, lua_KContext ctx, lua_KFunction k); #define lua_pcall(L,n,r,f) lua_pcallk(L, (n), (r), (f), 0, NULL) LUA_API int (lua_load) (lua_State *L, lua_Reader reader, void *dt, const char *chunkname, const char *mode); LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data, int strip); lua脚本的调用:
int32 error = luaL_loadbuffer(current_state, (char*)buffer, len, script_name) || lua_pcall(current_state, 0, 0, 0); luaL_loadbuffer函数最终会调用lua_load,将加载的脚本打包成一个function放入栈顶,最后由lua_pcall运行这个function,完成脚本的加载.从此,这个脚本的内容就在lua的环境里了,除了一些local修饰的内容,其余所有内容都能被任何其他脚本访问.
lua函数的执行
//ygopro里使用这个函数来运行lua函数 lua_pcall(L, //lua对象 n, //参数数量 r, //返回值的数量 f) //不关心这玩意 填0就行 //作用:运行栈顶上的函数,从栈上取出相应数量的参数,运行完之后将相应数量的返回值放入栈顶,供C读取 userdata userdata是一类特殊的数据,用来保存lua中没有的数据类型(一般是C中的指针)
//这个函数以给定的大小分配一个新的内存块，将一个新的完整的用户数据和块地址压入堆栈，并返回这个地址。主机程序可以自由地使用这些内存 LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz); 引用 //在t索引处 创建栈顶元素的引用,并返回引用值 这个操作会弹出栈顶元素 t索引处是个表 LUALIB_API int (luaL_ref) (lua_State *L, int t); //解除t处 ref代表的引用 LUALIB_API void (luaL_unref) (lua_State *L, int t, int ref); 引用建立完成之后大概是这样的,t索引处的表 添加了一对键值对
┌──────────table at t──────────────┐ │ │ │ │ │ key value │ │ │ │ │ │ ref = element from stack top │ │ │ │ └──────────────────────────────────┘ 关于引用的一个坑
luaL_ref会返回引用值ref,是int类型.
那么,lua实例创建的第一个引用的ref值是多少? 在lua5.3 中,这个值是3
在lua5.4 中,这个值是4
真的太cooool了!
duel* interpreter::get_duel_info(lua_State * L) { luaL_checkstack(L, 1, NULL); lua_rawgeti(L, LUA_REGISTRYINDEX, 3); //good job duel* pduel = (duel*)lua_topointer(L, -1); lua_pop(L, 1); return pduel; } 注册表 注册表是一种特别的表,它一直存在于虚拟栈中,但它是"隐形"的,所有操作栈的函数都会无视它的存在. 只能通过 &ldquo;LUA_REGISTRYINDEX&rdquo; 这个索引去访问它.
在ocgcore中,userdata 引用 注册表,这三者经常合在一起使用,比如下面的代码,在LUA_REGISTRYINDEX中注册了一个效果effect*
void interpreter::register_effect(effect *peffect) { if (!peffect) return; //create a effect in by userdata luaL_checkstack(lua_state, 3, NULL); effect ** ppeffect = (effect**) lua_newuserdata(lua_state, sizeof(effect*)); //在栈顶新建一块userdata,存储effect*变量,返回值类型是(effect**) *ppeffect = peffect; //新建的userdata存储的effect*变量 指向了形参 peffect peffect->ref_handle = luaL_ref(lua_state, LUA_REGISTRYINDEX); //将在在注册表中创建引用 //set metatable of pointer to base script lua_rawgeti(lua_state, LUA_REGISTRYINDEX, peffect->ref_handle); lua_getglobal(lua_state, "Effect"); lua_setmetatable(lua_state, -2); lua_pop(lua_state, 1); } 这段程序运行之后会变成这样
┌───────LUA_REGISTRYINDEX───┐ │ │ │ │ │ key value │ │ │ ├┬────┐ │ ┌───────────┐ ││ref │ peffect ────┼───► │ │┼────┤ │ │ effect │ └───┼─┴─────────────────────┘ │ │ │ └─────┬─────┘ │ │ └─────────────────────────────────┴─ "Effect"是 peffect的元表 为什么要这么麻烦设置这么一堆东西?
通过ref可以立即获取到userdata到栈上
userdata是指针,是未知类型的,指向的内容未知,
这时,可以获取它的元表,看元表是什么,如果元表是"Effect",代表这个指针指向effect,如果元表是"Card",代表这个指针指向card&hellip;&hellip;
lua调用C函数 编写脚本时,我们可以使用5个函数库: Card 库，Group 库，Effect 库，Duel 库以及 Auxiliary 库
其中Auxiliary库是一个需要加载的lua文件,其余4个全部都是调用的C++函数,是写死在ocgcore中的.
拿一个最短的Duel库来举例:
static const struct luaL_Reg debuglib[] = { { "Message", scriptlib::debug_message }, { "AddCard", scriptlib::debug_add_card }, { "SetPlayerInfo", scriptlib::debug_set_player_info }, { "PreSummon", scriptlib::debug_pre_summon }, { "PreEquip", scriptlib::debug_pre_equip }, { "PreSetTarget", scriptlib::debug_pre_set_target }, { "PreAddCounter", scriptlib::debug_pre_add_counter }, { "ReloadFieldBegin", scriptlib::debug_reload_field_begin }, { "ReloadFieldEnd", scriptlib::debug_reload_field_end }, { "SetAIName", scriptlib::debug_set_ai_name }, { "ShowHint", scriptlib::debug_show_hint }, { NULL, NULL } }; void scriptlib::open_debuglib(lua_State *L) { luaL_newlib(L, debuglib); lua_setglobal(L, "Debug"); } 可以看出来:这些函数确实是"Debug"里的一个普通字符串.调用方法是Debug.XXXXXX
编写卡片脚本看见拿不准的函数时,可以去看一下对应的C++函数具体都干了些什么.
也可以自己添加新的函数,便于自己使用.</content></entry><entry><title>ygopro源码分析1:源码的获取&编译</title><url>http://rayrain.xyz/ygopro1/</url><categories/><tags><tag>ygopro</tag></tags><content type="html"> 1.简介 ygopro是一个开源免费的游戏王模拟器,原作者是Fluorohydride(圆神),可以模拟几乎所有的游戏王卡片,并且在源码的级别上同时支持windows linux 和macos等操作系统.圆神神隐后由决斗者们维护到现在,主要有mycard和233两个服务器.
源码由3部分组成,还用了若干的第三方库.
ygopro:游戏的客户端本体
|-irrlicht:游戏引擎,负责游戏画面和GUI
|-freetype:字体引擎,负责让irrlicht显示中文
|-sqlite3:轻量级数据库,存储卡片的数据,用于卡片的查找搜寻
|-libevent2:网络库,实现联机对战
|-lzma:压缩算法,用于游戏录像文件
|-IrrKlang:音频引擎
ocgcore:脚本处理引擎
|-lua5.3:用于读取各种脚本
script:lua编写的卡片脚本
需要用到的软件 git vscode cmake msvc(需要安装visual studio获取) sqlitebrowser: 用于浏览card数据库 DataEditorX: ygopro的定制card数据库操作软件 vcpkg(可选): 可以更方便的管理第三方库 2.源码获取以及编译 2.1 下载源码 由于原版ygopro的代码过于感人,所以选用了KoishiPro.
KoishiPro是ygopro的pro版,代码比较规范.
git clone --recurse https://github.com/purerosefallen/ygopro.git 这个命令可以源码的3部分全部下载下来.不包括第三方库.
(如果你使用的是ubuntu系的linux的话,直接安装好相关的库,然后cmake就能一键编译了,本文就不用看了)
ygopro的官方貌似使用premake来构筑代码,但也有人为其编写CMake脚本,接下来我们会使用cmake来构筑代码.
2.2 使用vs编译 我不喜欢VS这种重量级的IDE,如果想要用VS编译的话,可以参考尸体233的Travis CI脚本, 或者KoishiPro自带的编译脚本. 手动按照脚本中的步骤一步步操作,可以生成sln项目文件,然后就能用VS编译了,下面的内容就不用看了.
2.3 使用vscode编译 首先需要安装cmake cmaketool C++等插件
VS也得装,记得装C++开发环境,以获取msvc.
使用vcpkg管理第三方库 windows上没有包管理工具,想要用什么库都得手动下载,手动编译,而且大概率都是一次性使用,这个过程比较痛苦,如果不想这么麻烦的话建议使用vcpkg来管理第三方库.
具体使用方法我就不多说了,懂得都懂,官方文档.
不过使用这个方法需要稍微修改下CMakeLists.txt文件.
手动下载各个第三方库 先打开工程根目录的CMakeLists.txt,找到这部分
if (MSVC) add_subdirectory (event) add_subdirectory (freetype) add_subdirectory (irrlicht) add_subdirectory (sqlite3) add_subdirectory (lua) 可以看到,我们的目标就是在根目录创建上面相应的文件夹,同时每个文件夹根目录里都需要有一个CMakeLists.txt文件.
下面是各个库的下载地址(暂时忽略IrrKlang)
event
freetype
irrlicht
sqlite3
lua
然后我们把这些库都解压到工程的根目录下的相应文件夹下(这些文件夹需要自行修改成 event freetype irrlicht sqlite3 lua这些名字), 同时需要保证每个文件夹根目录里都需要有一个CMakeLists.txt文件.
目录大概是这样 |-ygopro ├─event │ └─CMakeLists.txt ├─freetype | └─CMakeLists.txt ├─irrlicht | └─CMakeLists.txt ├─sqlite3 | └─CMakeLists.txt ├─lua | └─CMakeLists.txt 记得用vscode打开ygopro工程文件夹.
修改部分CMakeLists.txt脚本 现在除了lua和sqlite3之外,其余3个库都已经准备好了CMakeLists.txt文件.
所以现在要为lua和sqlite3添加CMakeLists.txt编译脚本. #sqlite3的编译脚本 project(sqlite3) file(GLOB SQL_SRC ./*.c) add_library(sqlite3 STATIC ${SQL_SRC}) #lua的编译脚本 #需要删除 src/luac.c 这个是命令行程序,有main函数 project(lua) file(GLOB LUA_SRC ./src/*.c) add_library(lua STATIC ${LUA_SRC}) event的编译脚本需要做一些修改 #在前面的option部分 把EVENT__DISABLE_OPENSSL打开 ,关闭对openssl的依赖 option(EVENT__DISABLE_OPENSSL "Define if libevent should build without support for OpenSSL encryption" ON) event的编译脚本默认会编译一些test,我们不需要,
把995行 sample处 以下的内容全部注释
irrlicht设置不使用D3D9编译 //在IrrCompileConfig.h这个文件 (156行之前) 加入下面这行 #define NO_IRR_COMPILE_WITH_DIRECT3D_9_ 修改lua的路径 我们lua库的路径是 lua/src,ocgcore的CMakeLists需要修改成如下: project (ocgcore) set (AUTO_FILES_RESULT) AutoFiles("." "src" "\\.(cpp|c|h)$") if (MSVC) include_directories ( ../lua/src ) #正确的lua路径 else () include_directories ( ${LUA_INCLUDE_DIR} ) endif () add_library (ocgcore STATIC ${AUTO_FILES_RESULT}) if (MSVC) target_link_libraries (ocgcore lua) else () target_link_libraries (ocgcore ${LUA_LIBRARIES}) endif () 一些其他修改 lua.h相关 ocgcore是C++工程,应该把 interpreter.h中 14行 改成 lua.hpp 编译 使用vscode打开ygopro文件夹后,如果cmake tool 和C++插件被正确安装的话,最下方的栏位里会出现cmake的一些选项,其中kit能够识别出电脑上的编译环境. 我们选择kit为: &ldquo;Visual Studio Community 2019 -amd64_x86&rdquo;(不同电脑上可能有差异),然后点击build.经过一段时间后就可以编译出ygopro.exe文件了,到这里就算编译成功了.
编译技巧 可以看到根目录的CMakeLists.txt里有很多add_subdirectory,每一个都代表了一个project,为了方便的检测修改的CMakeLists.txt是否正确,可以先把其他的add_subdirectory注释掉,只留下一个,这样就可以逐个编译了.
BTW 另外cmake配合msvc使用是可以生成sln工程文件的,这时候就可以直接双击sln,使用vs来编译了.
一些可能的其他错误 我们下载的irrlicht是mycard特殊修改的版本,如果你使用的是其他地方的irrlicht,有可能会遇到问题.
这个地方c_str()的返回值是char*型,和 wchar_t*不符合,会报错 const wchar_t* fname = archive->getFullFileName(j).c_str(); 在合适的地方定义这个函数,可以将char* 转换成wchar_t*
#include &lt;stringapiset.h> wchar_t* AnsiToUnicode(const char* szStr) { int nLen = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szStr, -1, NULL, 0 ); if (nLen == 0) { return NULL; } wchar_t* pResult = new wchar_t[nLen]; MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szStr, -1, pResult, nLen ); return pResult; } 然后
把出错的这行改成 const wchar_t* fname =AnsiToUnicode( archive->getFullFileName(j).c_str()); 运行 打开mycard下的ygopro或者尸体233的ygopro的根目录,将pics(卡图目录),script(脚本目录),textures(游戏素材),cards.cdb(卡片数据库)和各种conf文件都复制到我们的编译目录,和ygopro.exe同级,然后就可以运行了. 输入
s1.ygo233.com 233 就可以和233服的玩家决斗了.
(建议把本工程的conf文件也放进去)</content></entry><entry><title>卡片脚本编写</title><url>http://rayrain.xyz/cardscript/</url><categories/><tags><tag>ygopro</tag><tag>lua</tag></tags><content type="html"> 杂记 永续魔法卡 等 发动后停留在场上,这个行为是客户端实现的 s代表自己 o代表对方
触发型效果 参数名 全称 含义 e Effect 这个效果本身 tp This Player 发动效果的玩家 eg Event Group 触发这个时点时涉及的卡片组 ep Event Player 触发这个时点时涉及的玩家 ev Event Value 触发这个时点时涉及的数值/连锁序号(仅限连锁相关的时点) re Reason Effect 触发这个时点的原因效果 r Reason 触发这个时点的原因 rp Reason Player 触发这个时点的原因玩家 Effect的属性 Category 卡片效果类型的tag,如:哥布林暴发户 的Category是
e1:SetCategory(CATEGORY_DRAW+CATEGORY_RECOVER) 抽卡效果 和 回复效果 抽卡效果可以被灰流丽响应
Type 指效果的类型
e1:SetType(EFFECT_TYPE_ACTIVATE) 魔陷发动,拥有这个类型才可以当作魔陷在魔陷区发动 Target SetRange 效果的生效位置,这张卡只有在生效位置再能发挥效果
e2:SetRange(LOCATION_SZONE) 该效果在魔陷区域才有效,离开后就无效了</content></entry><entry><title>ocgcore分析</title><url>http://rayrain.xyz/ygocore/</url><categories/><tags><tag>ygopro</tag><tag>lua</tag></tags><content type="html"> 简介 ygopro的核心被叫做ocgcore,实际上不止支持OCG,还支持TCG等等,顺带一提,早期的ygopro更多的被人称为ygocore,现在的相关贴吧还叫"游戏王ygocore"
记录 加载卡片脚本 int32 interpreter::load_card_script(uint32 code) { //假定code=123456 //首先看lua环境里面有没有 c123456这个变量,有的话就将这个变量放入栈顶 char class_name[20]; sprintf(class_name, "c%d", code); luaL_checkstack(current_state, 1, NULL); lua_getglobal(current_state, class_name); if (lua_isnil(current_state, -1)) { //没有c123456 所以放到栈顶的是nil luaL_checkstack(current_state, 5, NULL); lua_pop(current_state, 1); //弹出栈顶的nil lua_createtable(current_state, 0, 0); //创建一个空表到栈顶 lua_setglobal(current_state, class_name); //弹出空表,另c123456 = 空表 以下称table(c123456) lua_getglobal(current_state, class_name); //将table(c123456) 入栈 lua_getglobal(current_state, "Card"); //将"Card"入栈 lua_setmetatable(current_state, -2); //弹出栈顶的"Card" 将"Card"设置为table(c123456)的元表 lua_pushstring(current_state, "__index"); //字符串"__index"入栈 lua_pushvalue(current_state, -2); //table(c123456)复制一份到栈顶 lua_rawset(current_state, -3); //table(c123456).__index=table(c123456) char script_name[64]; sprintf(script_name, "./script/c%d.lua", code); if(!load_script(script_name)) { //加载相应的lua脚本文件 return OPERATION_FAIL; } } return OPERATION_SUCCESS; } 状态status 添加一个处理单元 void field::add_process(uint16 type, 此单元的类型 uint16 step, 这个单元的进度 effect* peffect, group* target, ptr arg1, ptr arg2, ptr arg3, ptr arg4, void* ptr1, void* ptr2) ┌────────────────┐ ┌─────────────────────┐ │ │ │ │ ┌────────────────────┐ │ │ │ │ data │ │ │ core ├──────────────── │ client │ ────────────── │ server │ │ │ │ │ │ │ └────────────────┘ │ │ │ │ └─────────────────────┘ └────────────────────┘ 16bit 8bit ┌────────────────┬────────┬──────────────────────────┐ │ │ │ │ │ len │ proto │ EX buffer │ └────────────────┴────────┴──────────────────────────┘ 8bit ┌────────┬──────────────┐ │ │ │ GAME_MSG │ msg │ buffer │ └────────┴──────────────┘ other_MSG</content></entry><entry><title>lua note</title><url>http://rayrain.xyz/lua/</url><categories/><tags><tag>lua</tag></tags><content type="html"> lua简介 lua是一门嵌入式的脚本语言,其存在的意义就是给C/C++等高级语言打下手,当一个好配角.
对于C/C++来说,lua的作用主要体现在:在C/C++程序没有重新编译,甚至没有重启的情况下,只通过改变lua脚本的内容,令C/C++程序做出不一样的行为.
一些有用的链接:
lua菜鸟教程
lua5.3官方手册
lua程序设计
lua实际上是一个库,命令行里的可交互程序luac是lua库的副产物,只有400多行,很少用到.
lua可以嵌入到C程序里,但lua和C是两个完全不一样的世界,lua中的变量只能由lua管理,C语言中的值lua也不知道,双方只能通过一个虚拟栈来交换信息.C和lua之间也主要是围绕着"lua虚拟栈" &ldquo;lua环境&rdquo; &ldquo;C环境&rdquo; 编程的.
本文中出现的lua API不一定全部解释,请查阅lua5.3官方手册
创建一个lua对象 lua_State *L = luaL_newstate(); lua虚拟栈 lua虚拟栈是这样的--> | 栈顶 | 索引值:-1 -------- | | ------- | 栈底 | 索引值:1 ------- 和一般的栈没有什么不同的 栈基本操作 //取出栈顶的元素,赋给全局变量,可以新建全局变量 LUA_API void (lua_setglobal) (lua_State *L, const char *name); //idx[k] = v v是索引-1处的值 , k是索引-2的值 //并将k和v 弹出堆栈 这个函数可以触发__newindex元方法 LUA_API void (lua_settable) (lua_State *L, int idx); //如果idx处是个table,弹出栈顶的元素 赋值给改table[k],k必须为字符串 LUA_API void (lua_setfield) (lua_State *L, int idx, const char *k); LUA_API void (lua_seti) (lua_State *L, int idx, lua_Integer n); //跟lua_settable一样 不会调用元方法 LUA_API void (lua_rawset) (lua_State *L, int idx); LUA_API void (lua_rawseti) (lua_State *L, int idx, lua_Integer n); LUA_API void (lua_rawsetp) (lua_State *L, int idx, const void *p); //从堆栈中弹出一个表，并将其设置为给定索引值objindex的新元表 LUA_API int (lua_setmetatable) (lua_State *L, int objindex); LUA_API void (lua_setuservalue) (lua_State *L, int idx); stack&ndash;>C //索引处是否是数字或可转换成数字的字符串 LUA_API int (lua_isnumber) (lua_State *L, int idx); //索引处 是否是字符串 或者可转换成字符串的数字 LUA_API int (lua_isstring) (lua_State *L, int idx); LUA_API int (lua_iscfunction) (lua_State *L, int idx); LUA_API int (lua_isinteger) (lua_State *L, int idx); LUA_API int (lua_isuserdata) (lua_State *L, int idx); LUA_API int (lua_type) (lua_State *L, int idx); LUA_API const char *(lua_typename) (lua_State *L, int tp); LUA_API lua_Number (lua_tonumberx) (lua_State *L, int idx, int *isnum); LUA_API lua_Integer (lua_tointegerx) (lua_State *L, int idx, int *isnum); LUA_API int (lua_toboolean) (lua_State *L, int idx); LUA_API const char *(lua_tolstring) (lua_State *L, int idx, size_t *len); LUA_API size_t (lua_rawlen) (lua_State *L, int idx); LUA_API lua_CFunction (lua_tocfunction) (lua_State *L, int idx); LUA_API void *(lua_touserdata) (lua_State *L, int idx); LUA_API lua_State *(lua_tothread) (lua_State *L, int idx); LUA_API const void *(lua_topointer) (lua_State *L, int idx); C&ndash;>stack //向栈中推入一个nil LUA_API void (lua_pushnil) (lua_State *L); //向栈中推入一个double数字 LUA_API void (lua_pushnumber) (lua_State *L, lua_Number n); //推入longlong数字 LUA_API void (lua_pushinteger) (lua_State *L, lua_Integer n); //推入字符串的前len个元素 LUA_API const char *(lua_pushlstring) (lua_State *L, const char *s, size_t len); //推入字符串 LUA_API const char *(lua_pushstring) (lua_State *L, const char *s); //va_list用法 LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,va_list argp); //推入格式化输出的字符串 LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...); //推入闭包 LUA_API void (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n); //推入布尔值 LUA_API void (lua_pushboolean) (lua_State *L, int b); //推入用户数据 LUA_API void (lua_pushlightuserdata) (lua_State *L, void *p); LUA_API int (lua_pushthread) (lua_State *L); lua&ndash;>stack //将存在的全局变量压入栈顶 LUA_API int (lua_getglobal) (lua_State *L, const char *name); //将存在的table 压入栈顶lua_setmetatable LUA_API int (lua_gettable) (lua_State *L, int idx); //如果idx索引处是table,将该table[k]放到栈顶,k必须为字符串 LUA_API int (lua_getfield) (lua_State *L, int idx, const char *k); LUA_API int (lua_geti) (lua_State *L, int idx, lua_Integer n); LUA_API int (lua_rawget) (lua_State *L, int idx); //将t[n]压入堆栈,t是索引idx处的表,不会调用__index元方法 LUA_API int (lua_rawgeti) (lua_State *L, int idx, lua_Integer n); LUA_API int (lua_rawgetp) (lua_State *L, int idx, const void *p); //创建一个空的table并压入栈中，并预分配narr个array元素的空间和预分配nrec个非array元素的空间 LUA_API void (lua_createtable) (lua_State *L, int narr, int nrec); //这个函数以给定的大小分配一个新的内存块，将一个新的完整的用户数据和块地址压入堆栈，并返回这个地址。主机程序可以自由地使用这些内存 LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz); LUA_API int (lua_getmetatable) (lua_State *L, int objindex); LUA_API int (lua_getuservalue) (lua_State *L, int idx); //如果idx处是一个table,获取该table的fname索引,并压入栈顶 LUALIB_API int (luaL_getsubtable) (lua_State *L, int idx, const char *fname); stack&ndash;>lua //取出栈顶的元素,赋给全局变量,可以新建全局变量 LUA_API void (lua_setglobal) (lua_State *L, const char *name); //idx[k] = v v是索引-1处的值 , k是索引-2的值 //并将k和v 弹出堆栈 这个函数可以触发__newindex元方法 LUA_API void (lua_settable) (lua_State *L, int idx); //如果idx处是个table,弹出栈顶的元素 赋值给改table[k],k必须为字符串 LUA_API void (lua_setfield) (lua_State *L, int idx, const char *k); LUA_API void (lua_seti) (lua_State *L, int idx, lua_Integer n); //跟lua_settable一样 不会调用元方法 LUA_API void (lua_rawset) (lua_State *L, int idx); LUA_API void (lua_rawseti) (lua_State *L, int idx, lua_Integer n); LUA_API void (lua_rawsetp) (lua_State *L, int idx, const void *p); //从堆栈中弹出一个表，并将其设置为给定索引值objindex的新元表 LUA_API int (lua_setmetatable) (lua_State *L, int objindex); LUA_API void (lua_setuservalue) (lua_State *L, int idx); load &amp; call LUA_API void (lua_callk) (lua_State *L, int nargs, int nresults, lua_KContext ctx, lua_KFunction k); #define lua_call(L,n,r) lua_callk(L, (n), (r), 0, NULL) LUA_API int (lua_pcallk) (lua_State *L, int nargs, int nresults, int errfunc, lua_KContext ctx, lua_KFunction k); #define lua_pcall(L,n,r,f) lua_pcallk(L, (n), (r), (f), 0, NULL) LUA_API int (lua_load) (lua_State *L, lua_Reader reader, void *dt, const char *chunkname, const char *mode); LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data, int strip); //加载一个文件并执行 #define luaL_dofile(L, fn) (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0)) 表和元方法 表是lua中用途最广泛的结构,
注册表和引用</content></entry><entry><title>hugo相关操作</title><url>http://rayrain.xyz/hugo_manual/</url><categories/><tags><tag>hugo</tag></tags><content type="html"> hugo简单操作
生成仓库中需要的内容 hugo 运行hugo服务器 hugo server push到仓库 git remote add origin git@github.com:Reisen1969/Reisen1969.github.io.git git push origin master</content></entry><entry><title>ygopro源码分析</title><url>http://rayrain.xyz/ygopro/</url><categories/><tags><tag>ygopro</tag></tags><content type="html"> 总览 1.简单介绍 ygopro是一个开源免费的游戏王模拟器,可以模拟几乎所有的游戏王卡片,并且在源码的级别上同时支持windows linux 和macos等操作系统,不过这个项目的创建者Fluorohydride(圆神)从2016年就神隠了,这个项目由一群爱好者一直维护,还有两个主要的对战服务器,233服和萌卡mycard.
本文的读者想必都是决斗者了,一些专有名词就不解释了,默认大家都懂了.
源码由3部分组成,还用了若干的第三方库.
ygopro:游戏的客户端本体 |-irrlicht:游戏引擎,负责游戏画面和GUI |-freetype:字体引擎,负责让irrlicht显示中文 |-sqlite3:轻量级数据库,存储卡片的数据,用于卡片的查找搜寻 |-libevent2:网络库,实现联机对战 |-lzma:压缩算法,用于游戏录像 ocgcore:脚本处理引擎 |-lua5.3:用于读取各种脚本 script:lua编写的卡片脚本 ygopro使用的音频引擎是irrKlang,不开源,我直接选择性忽略了.
我全程在archlinux上分析的源码,文中有关windows的地方我都验证过了
不会分析TAG模式和replay
2.前期准备 2.1 下载源码 git clone --recurse https://github.com/Fluorohydride/ygopro.git 这个命令可以源码的3部分全部下载下来.不包括第三方库.
然后就是编译了,打开文件夹后可以看到本项目似乎支持cmake和premake4.
实际上这个CMakeList文件的编写者是在ubuntu系linux下测试的,如果你使用ubuntu系的linux的话,安装好各种库之后就可以用cmake一键编译了,如果不是的话就往下看吧.
2.2 使用VisualStudio编译 我不太喜欢这个重量级的软件,如果想要用vs编译的话,建议去参考尸体233的Travis CI脚本,按照这个脚本一步步操作,可以生成sln项目文件,然后就能用vs编译了,下面的内容就可以直接跳过去了,直接去看第3节了.
2.3 使用vcpkg管理第三方库 如果你按照上面的操作使用vs编译的话,你需要下载一堆第三方库的源码,然后解压到指定目录,特别麻烦,而且这些库是"一次性"的,所以我推荐使用vcpkg去统一管理这些第三方库,具体使用方法我就不多说了,懂得都懂,官方文档.
我用的linux,自带包管理工具,也需要用vcpkg吗?
如果使用的是非ubuntu系的话,还是建议使用,因为vcpkg可以完美嵌入cmake,如果使用的是自带的包管理工具的话,可能cmake无法find到某个库,头文件路径也可能跟代码有出入,用了vcpkg,这一切就都解决了.
2.4 使用vscode 如果没有选择vs的话,vscode就是最佳选择了,话是这么说,但vs改装还得装,因为编译器msvc是必须的. 需要的vscode插件:C/C++ ,CMake 和CMake Tools.
关于CLion
我使用过一段时间的CLion,它的体验基本上跟vscode一致,但存在一些缺点:
占用资源比较大 多线程调试很差,甚至不如直接用gdb.(这是我遇到的问题,我没找到原因) 2.5 linux上使用cmake+gcc编译 如上面所说,使用vcpkg管理第三方库,嵌入项目自带的CMakeLists文件即可.
具体做法:将原本的第三方库相关内容去掉换成vcpkg
2.6 windows上使用cmake+msvc编译 杂项 游戏配置的读取 ygopro所有的游戏配置都写在文本文件里
lflist.conf 禁卡表文件,包含了所有的禁卡表 strings.conf 在客户端上显示的所有文字 system.conf 一些设置选项 irrlicht irrlicht是一个古老的游戏引擎,网上几乎没有什么中文资料,不过对于ygopro来说,只用了一些简单的图形效果和很复古的GUI,比如下面的程序通过改变卡片的横坐标来表示卡组的洗牌动画
for (auto cit = mainGame->dField.deck[player].begin(); cit != mainGame->dField.deck[player].end(); ++cit) { (*cit)->dPos = irr::core::vector3df(rnd.rand() * 0.4f / rnd.rand_max - 0.2f, 0, 0); (*cit)->dRot = irr::core::vector3df(0, 0, 0); (*cit)->is_moving = true; (*cit)->aniFrame = 3; } 想学习irrlicht的话建议去看官方的Tutorials.
irrlicht写的非常规范,容易阅读,但毕竟十几年前的产物了,并不推荐用这个制作游戏.
I 开头的是 纯虚接口类 C 开头的是 接口实现类 E 是枚举值 S 是结构体 irrlichtr是个3D引擎,想深入学习需要OpenGL或者Direct3D相关的知识.
但是对于ygopro来说,只需要了解下面这两点就可以了
1.irrlicht的初始化操作
首先需要获取一个IrrlichtDevice,这是irrlicht最根本的对象,有两种方法得到
自定义params,也是ygopro使用的方法 IrrlichtDevice* device; irr::SIrrlichtCreationParameters params = irr::SIrrlichtCreationParameters(); //对params做一些自定义 device = irr::createDeviceEx(params); 或者 使用默认params 函数原型: IrrlichtDevice* createDevice( video::E_DRIVER_TYPE deviceType = video::EDT_SOFTWARE, const core::dimension2d&lt;u32>&amp; windowSize = (core::dimension2d&lt;u32>(640,480)), u32 bits = 16, bool fullscreen = false, bool stencilbuffer = false, bool vsync = false, IEventReceiver* receiver = 0); 使用IrrlichtDevice获取其他对象
获取IVideoDriver,所有图形相关的接口 IVideoDriver* driver = device->getVideoDriver(); 获取IGUIEnvironment,用于管理所有GUI组件 IGUIEnvironment* env = device->getGUIEnvironment(); 获取ISceneManager,管理camera 等其他资源 ISceneManager* smgr = device->getSceneManager(); 主循环
while(device->run()) { //绘制GUI 绘制图形 //接收玩家输入等 } 2.GUI相关
irrlicht的GUI还是比较落后的.ygopro用了七八百行,来添加GUI元素
添加GUI的步骤
首先去要预先定义一些宏来表示GUI的id(类似QT里的信号),如: #define BUTTON_LAN_MODE 100 #define BUTTON_SINGLE_MODE 101 #define BUTTON_REPLAY_MODE 102 #define BUTTON_TEST_MODE 103 添加btn btnLanMode = env->addButton(rect&lt;s32>(10, 30, 270, 60), wMainMenu, BUTTON_LAN_MODE, dataManager.GetSysString(1200)); 添加checkbox chkHostPrepReady[i] = env->addCheckBox(false, rect&lt;s32>(250, 75 + i * 25, 270, 95 + i * 25), wHostPrepare, CHECKBOX_HP_READY, L""); 初始化这些元素时都有一个参数是id,当GUI元素被操作的时候这些id就代表了不同的信号. 如何使用GUI
需要一个对象来接受这些信号,从而使这些GUI元素发挥作用.在irrlicht里,这个对象被称为EventReceiver.
同一时刻,一个device只能有一个EventReceiver.
这行程序为device设置了一个EventReceiver device->setEventReceiver(&amp;menuHandler); 任意一个类,只要重写了OnEvent(const irr::SEvent&amp; event)方法,就可以成为EventReceiver
声明 class MenuHandler: public irr::IEventReceiver { public: virtual bool OnEvent(const irr::SEvent&amp; event); }; 实现 bool MenuHandler::OnEvent(const irr::SEvent&amp; event) { switch(event.EventType){ //获取event类型 case irr::EET_GUI_EVENT: //GUI事件 //根据id判断是哪个GUI元素,然后做出相应操作 s32 id = event.GUIEvent.Caller->getID(); case irr::EET_MOUSE_INPUT_EVENT: //鼠标输入事件 case irr::EET_KEY_INPUT_EVENT: //键盘输入事件 //判断哪个健被按下 switch(event.KeyInput.Key) } } sqlite ygopro使用sqlite把所有卡片的信息存储在cards.cdb这个文件中.可以使用sqlitebrowser来方便的操作这个文件.
cards.cdb中有两个表,datas和texts datas的内容是卡片的信息(用数字表示),texts的内容是跟卡片有关的字符串.
datas的表头如下:
id ot alias setcode type atk def level race attribute category 需注意:这些数值的用途大部分是在卡组构造界面搜索卡片
id :表示卡片的官方代码 ot :表示卡片的限制情况 0代表禁止 3代表无限制 alias:表示别名,有些卡片被科乐美复刻了多次,比如青眼白龙,复刻后的青眼白龙的alias就是初版青眼白龙的id setcode :一个10进制数,表示卡片所属的字段,把这个数转换成16进制可得到字段, 每个字段4位16进制数.strings.conf文件中存储了所有字段 举个例子:数据库中查到的setcode最大值的卡片是"希望皇 拟声乌托邦",所属字段是"刷拉拉(0x8f)" &ldquo;我我我(0x54)&rdquo; &ldquo;隆隆隆(0x59)&rdquo; &ldquo;怒怒怒(0x82)",这张卡片的setcode是36592129229979791, 转换成16进制是82 0059 0054 008F
type :一个10进制数,转换成2进制后,表示卡片类型. atk :攻击力 def:防御力 level: 等级 or 阶级 or link值 race:种族 attribute:属性 category:一个10进制数,转换成32bit的二进制数,恰好对应卡片搜索的中的32个效果. 举个例子:随机选择了一张卡"暗之支配者-佐克&rdquo;,其category值为134217730,写成二进制是00001000000000000000000000000010,倒着看,恰好对应第二个效果"怪兽破坏"和倒数第五个效果"幸运",
至于为什么要倒着看,因为代码中是通过下面的方式设置过滤选项的
long long filter = 0x1; for(int i = 0; i &lt; 32; ++i, filter &lt;&lt;= 1) if(mainGame->chkCategory[i]->isChecked()) filter_effect |= filter; texts的内容比较简单 就不展开了.
网络部分 当一个玩家点击"新建主机"时,会同时建立一个server和client,server会立即开始监听,然后client会立即连接server,当另一个玩家点击加入游戏时,会建立一个client按照地址和端口去连接server.
当server接收到client的连接后,会新建一个bufferevent建立与client之间的连接
非TAG模式下,第三个以上的玩家再加入游戏就会变成观众.
client给server发送数据 这个操作重载了3个函数
static void SendPacketToServer(unsigned char proto); template&lt;typename ST> static void SendPacketToServer(unsigned char proto, ST&amp; st); static void SendBufferToServer(unsigned char proto, void* buffer, size_t len); 实际上发送的数据有一个固定的格式
16bit 8bit 若干附加内容 1+附加内容的字节数 proto server接收到数据后 首先会根据数据的前两个字节(packet_len)来判断数据数否正确
if(len &lt; 2) return; evbuffer_copyout(input, &amp;packet_len, 2); //将数据的前两位 (包的长度) 复制到 packet_len if(len &lt; (size_t)packet_len + 2) return; 然后跳过表示packet_len的前两个字节,从第三个字节开始处理
void NetServer::HandleCTOSPacket(DuelPlayer* dp, char* data, unsigned int len); HandleCTOSPacket函数会根据不同的proto来做出不同的反应,处理过之后会通过下一节的函数来给玩家和观战者发送数据
server给client发送数据 同样重载了3个函数
static void SendPacketToPlayer(DuelPlayer* dp, unsigned char proto); template&lt;typename ST> static void SendPacketToPlayer(DuelPlayer* dp, unsigned char proto, ST&amp; st) static void SendBufferToPlayer(DuelPlayer* dp, unsigned char proto, void* buffer, size_t len); 发送数据的格式和上文一致
这个函数执行完之后通常需要立即执行
static void ReSendToPlayer(DuelPlayer* dp); 给另一个玩家以及观战者发送相同的数据
client接收到数据后 和server类似,client首先会根据数据的前两个字节(packet_len)来判断数据数否正确
if(len &lt; 2) return; evbuffer_copyout(input, &amp;packet_len, 2); if(len &lt; (size_t)packet_len + 2) return; 然后跳过表示packet_len的前两个字节,从第三个字节开始处理
void DuelClient::HandleSTOCPacketLan(char* data, unsigned int len); HandleSTOCPacketLan函数会通过不同的proto进行让client做出不同的操作</content></entry><entry><title>关于我</title><url>http://rayrain.xyz/about.html</url><categories/><tags/><content type="html"> a righteoux</content></entry><entry><title>Markdown语法手册</title><url>http://rayrain.xyz/markdown-syntax/</url><categories><category>themes</category><category>syntax</category></categories><tags><tag>markdown</tag><tag>css</tag><tag>html</tag></tags><content type="html"> 本文提供了一个可以在 Hugo 内容文件中使用的基本Markdown语法示例，还展示了基本 HTML 元素在 Hugo 主题中是否使用 CSS 装饰。
标题 下面的 HTML 代码&lt;h1>—&lt;h6> 元素表示六个级别的节标题。 &lt;h1>是最高的节级别，&lt;h6>是最低的节级别。
H1 H2 H3 H4 H5 H6 段落 Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.
伊塔图？厨房里有很多东西，我不知道他们喜欢吃什么，或者他们喜欢吃什么。
引用 blockquote元素表示从另一个来源引用的内容，可选的引用必须在footer或cite元素内，也可选的内嵌更改，如注释和缩写。
引用没有归属 Tiam, ad mint andaepu dandae nostion secatur sequo quae. 注意 可以在块引用中使用 Markdown 语法。
带归属的引用 不要通过分享记忆来交流，通过交流来分享记忆。
— 罗布·派克1
表格 表不是Markdown核心规范的一部分，但是Hugo支持开箱即用。
Name Age Bob 27 Alice 23 表格内使用Markdown语法 Italics Bold Code italics bold code 图像 ![图像描述](图像地址) 示例 Google Chrome Firefox Browser
点击图像可以打开图像浏览器，快试试吧。
代码块 带有引号的代码块 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 用四个空格缩进的代码块 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 代码块引用Hugo的内部高亮短代码 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 列表类型 有序列表 First item Second item Third item 无序列表 List item Another item And another item 嵌套列表 Fruit Apple Orange Banana Dairy Milk Cheese 其他元素 — abbr, sub, sup, kbd, mark GIF 是位图图像格式。
H2O
Xn + Yn = Zn
按 CTRL+ALT+Delete 组合键结束会话。
大多数蝾螈在夜间活动，捕食昆虫、蠕虫和其他小动物。
以上引文摘自Rob Pike在2015年11月18日Gopherfest上的演讲。&#160;&#8617;&#xfe0e;</content></entry><entry><title>占位符文本显示</title><url>http://rayrain.xyz/placeholder-text/</url><categories/><tags><tag>markdown</tag><tag>text</tag></tags><content type="html"> 你对我的心有偏见。我向您保证，我们的生活将不会受到影响，我们的生活将会受到影响。你说你现在住在医院里，因为你的眼睛是透明的，你的眼睛是光明的，你的眼睛是光明的!
Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.
Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt
The Van de Graaf Canon
Mane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.
Iubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.
Eurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.</content></entry><entry><title>数据公式设置显示</title><url>http://rayrain.xyz/math-typesetting/</url><categories/><tags/><content type="html"> Hugo项目中的数学表示法可以通过使用第三方JavaScript库来实现。
在这个例子中，我们将使用 MathJax
Create a post under /content/en[zh-CN]/math.md
可以全局启用MathJax，请在项目配置中将参数math设置为true
或是在每页基础上启用MathJax，在内容文件中包括参数math: true
注意： 使用支持的TeX功能的联机参考资料
例子 重复的分数 $$ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} \equiv 1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}} {1+\frac{e^{-8\pi}} {1+\cdots} } } } $$
总和记号 $$ \left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right) $$
几何级数之和 我把接下来的两个例子分成了几行，这样它在手机上表现得更好。这就是为什么它们包含 \displaystyle。
$$ \displaystyle\sum_{i=1}^{k+1}i $$
$$ \displaystyle= \left(\sum_{i=1}^{k}i\right) +(k+1) $$
$$ \displaystyle= \frac{k(k+1)}{2}+k+1 $$
$$ \displaystyle= \frac{k(k+1)+2(k+1)}{2} $$
$$ \displaystyle= \frac{(k+1)(k+2)}{2} $$
$$ \displaystyle= \frac{(k+1)((k+1)+1)}{2} $$
乘记号 $$ \displaystyle 1 + \frac{q^2}{(1-q)}+\frac{q^6}{(1-q)(1-q^2)}+\cdots = \displaystyle \prod_{j=0}^{\infty}\frac{1}{(1-q^{5j+2})(1-q^{5j+3})}, \displaystyle\text{ for }\lvert q\rvert &lt; 1. $$
随文数式 这是一些线性数学: $$ k_{n+1} = n^2 + k_n^2 - k_{n-1} $$ ， 然后是更多的文本。
希腊字母 $$ \Gamma\ \Delta\ \Theta\ \Lambda\ \Xi\ \Pi\ \Sigma\ \Upsilon\ \Phi\ \Psi\ \Omega \alpha\ \beta\ \gamma\ \delta\ \epsilon\ \zeta\ \eta\ \theta\ \iota\ \kappa\ \lambda\ \mu\ \nu\ \xi \ \omicron\ \pi\ \rho\ \sigma\ \tau\ \upsilon\ \phi\ \chi\ \psi\ \omega\ \varepsilon\ \vartheta\ \varpi\ \varrho\ \varsigma\ \varphi $$
箭头 $$ \gets\ \to\ \leftarrow\ \rightarrow\ \uparrow\ \Uparrow\ \downarrow\ \Downarrow\ \updownarrow\ \Updownarrow $$
$$ \Leftarrow\ \Rightarrow\ \leftrightarrow\ \Leftrightarrow\ \mapsto\ \hookleftarrow \leftharpoonup\ \leftharpoondown\ \rightleftharpoons\ \longleftarrow\ \Longleftarrow\ \longrightarrow $$
$$ \Longrightarrow\ \longleftrightarrow\ \Longleftrightarrow\ \longmapsto\ \hookrightarrow\ \rightharpoonup $$
$$ \rightharpoondown\ \leadsto\ \nearrow\ \searrow\ \swarrow\ \nwarrow $$
符号 $$ \surd\ \barwedge\ \veebar\ \odot\ \oplus\ \otimes\ \oslash\ \circledcirc\ \boxdot\ \bigtriangleup $$
$$ \bigtriangledown\ \dagger\ \diamond\ \star\ \triangleleft\ \triangleright\ \angle\ \infty\ \prime\ \triangle $$
微积分学 $$ \int u \frac{dv}{dx},dx=uv-\int \frac{du}{dx}v,dx $$
$$ f(x) = \int_{-\infty}^\infty \hat f(\xi),e^{2 \pi i \xi x} $$
$$ \oint \vec{F} \cdot d\vec{s}=0 $$
洛伦茨方程 $$ \begin{aligned} \dot{x} &amp; = \sigma(y-x) \ \dot{y} &amp; = \rho x - y - xz \ \dot{z} &amp; = -\beta z + xy \end{aligned} $$
交叉乘积 这在KaTeX中是可行的，但在这种环境中馏分的分离不是很好。
$$ \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \ \frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \ \frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \end{vmatrix} $$
这里有一个解决方案:使用“mfrac”类(在MathJax情况下没有区别)的额外类使分数更小:
$$ \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \ \frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \ \frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \end{vmatrix} $$
强调 $$ \hat{x}\ \vec{x}\ \ddot{x} $$
有弹性的括号 $$ \left(\frac{x^2}{y^3}\right) $$
评估范围 $$ \left.\frac{x^3}{3}\right|_0^1 $$
诊断标准 $$ f(n) = \begin{cases} \frac{n}{2}, &amp; \text{if } n\text{ is even} \ 3n+1, &amp; \text{if } n\text{ is odd} \end{cases} $$
麦克斯韦方程组 $$ \begin{aligned} \nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \ \nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \ \nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \ \nabla \cdot \vec{\mathbf{B}} &amp; = 0 \end{aligned} $$
这些方程式很狭窄。我们可以使用(例如)添加垂直间距 [1em] 在每个换行符(\)之后。正如你在这里看到的：
$$ \begin{aligned} \nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \[1em] \nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \[0.5em] \nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \[1em] \nabla \cdot \vec{\mathbf{B}} &amp; = 0 \end{aligned} $$
统计学 固定词组：
$$ \frac{n!}{k!(n-k)!} = {^n}C_k {n \choose k} $$
分数在分数 $$ \frac{\frac{1}{x}+\frac{1}{y}}{y-z} $$
ｎ次方根 $$ \sqrt[n]{1+x+x^2+x^3+\ldots} $$
矩阵 $$ \begin{pmatrix} a_{11} &amp; a_{12} &amp; a_{13}\ a_{21} &amp; a_{22} &amp; a_{23}\ a_{31} &amp; a_{32} &amp; a_{33} \end{pmatrix} \begin{bmatrix} 0 &amp; \cdots &amp; 0 \ \vdots &amp; \ddots &amp; \vdots \ 0 &amp; \cdots &amp; 0 \end{bmatrix} $$
标点符号 $$ f(x) = \sqrt{1+x} \quad (x \ge -1) f(x) \sim x^2 \quad (x\to\infty) $$
现在用标点符号:
$$ f(x) = \sqrt{1+x}, \quad x \ge -1 f(x) \sim x^2, \quad x\to\infty $$</content></entry><entry><title>支持Emoji表情符号</title><url>http://rayrain.xyz/emoji-support/</url><categories/><tags><tag>emoji</tag></tags><content type="html"> 在Hugo项目中可以通过多种方式启用Emoji。
The emojify function can be called directly in templates or Inline Shortcodes.
To enable emoji globally, set enableEmoji to true in your site&rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.
馃檲 🙈 馃檳 🙉 馃檴 🙊
The Emoji cheat sheet is a useful reference for emoji shorthand codes.
N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.
.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }</content></entry></search>