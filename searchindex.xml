<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>并行编程</title><url>http://rayrain.xyz/post/parallel/</url><categories/><tags><tag>多核</tag></tags><content type="html"> 参考:C++11中的内存模型
https://paul.pub/cpp-memory-model/
多核CPU架构 顺序一致性Sequential Consistency 每个处理器的执行顺序和代码中的顺序（program order）一样。 所有处理器都只能看到一个单一的操作执行顺序。 实际上还是相当于同一时间只有一个线程在工作，这种保证导致了程序是低效的，无法充分利用上多核的优点。
全存储排序（Total Store Ordering, 简称TSO） 在处理核心中增加写缓存，一个写操作只要写入到本核心的写缓存中就可以返回
松弛型内存模型（Relaxed memory models） 在松散型的内存模型中，编译器可以在满足程序单线程执行结果的情况下进行重排序（reorder),程序的执行顺序就不见得和代码中编写的一样了
内存栅栏（memory barrier） 由于有了缓冲区的出现，导致一些操作不用到内存就可以返回继续执行后面的操作，为了保证某些操作必须是写入到内存之后才执行，就引入了内存栅栏（memory barrier，又称为memory fence）操作。内存栅栏指令保证了，在这条指令之前所有的内存操作的结果，都在这个指令之后的内存操作指令被执行之前，写入到内存中。也可以换另外的角度来理解内存栅栏指令的作用：显式的在程序的某些执行点上保证SC。
关系术语 sequenced-before sequenced-before用于表示单线程之间，两个操作上的先后顺序，这个顺序是非对称、可以进行传递的关系。
它不仅仅表示两个操作之间的先后顺序，还表示了操作结果之间的可见性关系。两个操作A和操作B，如果有A sequenced-before B，除了表示操作A的顺序在B之前，还表示了操作A的结果操作B可见。
happens-before 与sequenced-before不同的是，happens-before关系表示的不同线程之间的操作先后顺序，同样的也是非对称、可传递的关系。
如果A happens-before B，则A的内存状态将在B操作执行之前就可见。在上一篇文章中，某些情况下一个写操作只是简单的写入内存就返回了，其他核心上的操作不一定能马上见到操作的结果，这样的关系是不满足happens-before的。
synchronizes-with synchronizes-with关系强调的是变量被修改之后的传播关系（propagate），即如果一个线程修改某变量的之后的结果能被其它线程可见，那么就是满足synchronizes-with关系的。
显然，满足synchronizes-with关系的操作一定满足happens-before关系了。
C++11内存模型 enum memory_order { memory_order_relaxed, //宽松 memory_order_consume, memory_order_acquire, //用来修饰一个读操作，表示在本线程中，所有后续的关于此变量的内存操作都必须在本条原子操作完成后执行。 memory_order_release, //用来修饰一个写操作，表示在本线程中，所有之前的针对该变量的内存操作完成后才能执行本条原子操作。 memory_order_acq_rel, //同时包含memory_order_acquire和memory_order_release标志 memory_order_seq_cst //一致性内存模型 默认 }; 原子操作分为三类
读load: memory_order_relaxed memory_order_consume memory_order_acquire memory_order_seq_cst
写store: memory_order_relaxed memory_order_release memory_order_seq_cst
读-改-写 :以上全部
memory_order_relaxed 宽松顺序
针对一个变量的读写操作是原子操作； 不同线程之间针对该变量的访问操作先后顺序不能得到保证，即有可能乱序。 x = 0; y = 0; // Thread 1: r1 = y.load(std::memory_order_relaxed); // A x.store(r1, std::memory_order_relaxed); // B // Thread 2: r2 = x.load(std::memory_order_relaxed); // C y.store(42, std::memory_order_relaxed); // D 可能会出现r1 = r2 = 42 的结果
这个内存模型的典型应用是计数器递增
memory_order_acquire 获得操作
用来修饰一个读操作，表示在本线程中，所有后续的关于此变量的内存操作都必须在本条原子操作完成后执行
如 lock()
memory_order_release 释放操作
用来修饰一个写操作，表示在本线程中，所有之前的针对该变量的内存操作完成后才能执行本条原子操作。
如unlock()
memory_order_acq_rel memory_order_consume 消费操作
上方的acq和rel的粒度太大了
#include &lt;thread> #include &lt;atomic> #include &lt;cassert> #include &lt;string> std::atomic&lt;std::string*> ptr; int data; void producer() { std::string* p = new std::string("Hello"); data = 42; ptr.store(p, std::memory_order_release); } void consumer() { std::string* p2; while (!(p2 = ptr.load(std::memory_order_consume))) ; assert(*p2 == "Hello"); // 绝无出错： *p2 从 ptr 携带依赖 assert(data == 42); // 可能也可能不会出错： data 不从 ptr 携带依赖 } int main() { std::thread t1(producer); std::thread t2(consumer); t1.join(); t2.join(); } memory_order_seq_cst // 线程 1 ： x.store(1, std::memory_order_seq_cst); // A y.store(1, std::memory_order_release); // B // 线程 2 ： r1 = y.fetch_add(1, std::memory_order_seq_cst); // C r2 = y.load(std::memory_order_relaxed); // D // 线程 3 ： y.store(3, std::memory_order_seq_cst); // E r3 = x.load(std::memory_order_seq_cst); // F 与volatile的关系 [https://www.codedump.info/post/20191214-cxx11-memory-model-1/]:</content></entry><entry><title>常用的网站</title><url>http://rayrain.xyz/post/web/</url><categories/><tags><tag>网站</tag></tags><content type="html"> 观察编译器背后行为的网站 https://godbolt.org/ https://www.godbolt.ms/
cpp的手册 https://en.cppreference.com/w/cpp
在线编译器 https://www.onlinegdb.com/online_c++_compiler
在线正则表达式 https://regex101.com/
ascii画图 https://asciiflow.com/legacy/</content></entry><entry><title>面试</title><url>http://rayrain.xyz/post/interview/</url><categories/><tags><tag>interview</tag></tags><content type="html"> C/C++相关 static 关键字 修饰局部变量, 修饰全局变量, 修饰成员变量, 修饰普通函数, 修饰成员函数, 修饰类,this指针等 const 关键字 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。 宏和常量的区别 宏定义 #define const 常量 宏定义，相当于字符替换 常量声明 预处理器处理 编译器处理 无类型安全检查 有类型安全检查 不分配内存 要分配内存 存储在代码段 存储在数据段 可通过 #undef 取消 不可取消 内存 栈stack, 只要出现花括号,就会开辟新栈 堆heap 未初始化全局变量bss, 初始化全局变量,存放全局数据和静态数据,又可细分为可读和可写区 代码段text,只读 内存泄漏 堆栈溢出
指针和引用 引用和指针的区别, 引用只是别名,不需要分配内存空间,指针是变量,需要分配内存空间
引用和指针的尺寸, 引用不占内存,指针的尺寸和cpu的字长有关.
右值引用,表示什么意思?有什么用?[完美转发是什么?] 可以实现移动语义,实现移动构造函数,避免深拷贝
STL中好多地方都用到了这个,如unique_ptr只支持移动构造函数
深拷贝和浅拷贝? inline关键字 有什么用?原理?优缺点? 和宏对比 类相关 如果不写构造函数,默认的构造函数是什么? 有两个:拷贝构造 赋值构造
初始化列表是什么?有什么好处?
静态类
多态 C++的多态是什么,实现的原理是什么? 编译器厂商都是用虚函数和虚表实现的
纯虚函数是什么? 构造函数和析构函数是否可以是虚函数?为什么? STL 简单介绍一下STL 一些容器的特性以及使用场景 vector 动态数组 ,size和capacity ,以及扩容机制,扩容完之后迭代器失效等等
list 双向链表
map和unordered_map
介绍一下迭代器
new delete 智能指针
如何避免临时对象生成 (可能是过时的)
临时对象一般是在栈上生成的,源码中不可见的对象,会多调用一次构造和析构函数
传参和返回时,尽量使用引用传递而不是值传递, 实参和形参要类型匹配,不要发生隐式类型转换,比如使用显式关键字explicit 单片机相关 C51等简单的单片机,问一下中断的概念
STM32等ARM核的高级单片机
中断 中断向量表 DMA等问题
QT相关 父类被析构时,需不需要手动析构子类对象,为什么? 对象树机制
操作系统相关</content></entry><entry><title>C++记录</title><url>http://rayrain.xyz/post/c++test/</url><categories/><tags><tag>C</tag><tag>CPP</tag></tags><content type="html"> cin读入逗号分隔的数字 #include&lt;bits/stdc++.h> using namespace std; int main() { vector&lt;int> data; string s; getline(cin,s); istringstream input; input.str(s); for(string line;getline(input,line,',');) { data.push_back(stoi(line)); } int sum = 0; for(auto i:data) sum+=i; cout&lt;&lt;sum; return 0; }</content></entry><entry><title>riscv 启动分析</title><url>http://rayrain.xyz/post/riscvhead/</url><categories/><tags><tag>riscv</tag><tag>kernel</tag></tags><content type="html"> 简单分析了下 relocate 和 setup_vm
首先是 setup_vm , 它设置了两个页表:
early_pg_dir,将内核自身处于的连续物理内存区域映射到位于PAGE_OFFSET的虚拟内存地址上 而FIXMAP映射并没有映射全部的FIXMAP，而是仅仅影射了FIX_FDT部分，让后续的代码可以访问设备树。
trampoline_pg_dir 将PAGE_OFFSET后长为PMD_SIZE的区域映射到load_pa，即内核起始被装载后的起始物理内存地址。
call relocate的地方:
/* Enable virtual memory and relocate to virtual address */ la a0, swapper_pg_dir //a0存储页表的物理地址 XIP_FIXUP_OFFSET a0 call relocate_enable_mmu 参数a0存储 页表的物理地址
//a0此时存储页表的物理地址 .align 2 #ifdef CONFIG_MMU .global relocate_enable_mmu relocate_enable_mmu: /* Relocate return address */ la a1, kernel_map //a1 = kermap的地址 XIP_FIXUP_OFFSET a1 REG_L a1, KERNEL_MAP_VIRT_ADDR(a1) la a2, _start //a2 = 镜像的地址 sub a1, a1, a2 //a1 = a1 - a2 //80001012 add ra, ra, a1 //得到ra的虚拟地址 //80201014 /* Point stvec to virtual address of intruction after satp write */ la a2, 1f //a2 = label1 的地址 add a2, a2, a1 //计算1f的新地址? //8000101e csrw CSR_TVEC, a2 //mtec //80201020 /* Compute satp for kernel page tables, but don't load it yet */ srl a2, a0, PAGE_SHIFT //a2 = a0>>PAGE_SHIFT 12 应该是PPN //80201024 la a1, satp_mode //a1 = satp_mode的地址 REG_L a1, 0(a1) or a2, a2, a1 //这里拼凑了stap寄存器 //80201032 /* * Load trampoline page directory, which will cause us to trap to * stvec if VA != PA, or simply fall through if VA == PA. We need a * full fence here because setup_vm() just wrote these PTEs and we need * to ensure the new translations are in use. */ la a0, trampoline_pg_dir //a0 = t表的地址 XIP_FIXUP_OFFSET a0 srl a0, a0, PAGE_SHIFT //取t表地址的高部分 //8000103c or a0, a0, a1 //或 satp_mode //8000103e sfence.vma //80001040 csrw CSR_SATP, a0 //设置CSR_SATP寄存器 //80001044 .align 2 1: /* Set trap vector to spin forever to help debug */ la a0, .Lsecondary_park csrw CSR_TVEC, a0 //80001050 /* Reload the global pointer */ .option push .option norelax la gp, __global_pointer$ .option pop /* * Switch to kernel page tables. A full fence is necessary in order to * avoid using the trampoline translations, which are only correct for * the first superpage. Fetching the fence is guaranteed to work * because that first superpage is translated the same way. */ csrw CSR_SATP, a2 //8000105c sfence.vma ret //80001064 trampoline_pg_dir表实际上是多余的,</content></entry><entry><title>常用的正则表达式</title><url>http://rayrain.xyz/post/regex/</url><categories/><tags><tag>正则</tag></tags><content type="html"> 本文记录一下浏览代码时比较常用的正则表达式
在线练习网站
单词边界 \b 匹配单词的开头和结尾
re: \bhi str: history 匹配前两个字符
re: ry\b str: history 匹配后两个字符
re: \bhistory\b str: history 匹配整个字符
什么能被称为边界?
字母和 [空格 汉字 标点] 之间的分界,但是空格 汉字 标点之间不能算是分界
单词非边界 \B 匹配的结果不能是字母和 [空格 汉字 标点] 之间的分界
re: ry\B str: history 无法匹配
re: \Bst\B str: history 可以匹配到中间的字符
匹配文件的开头 \A 只能匹配文件的开头
匹配文件的结尾 \Z 只能匹配文件的结尾
匹配一行的开头 ^ 匹配一行的结尾 $ 匹配某个函数 main_\w+_start\(\) main_AA_start() main_BB_start() main_CC_start()</content></entry><entry><title>linux相关工具</title><url>http://rayrain.xyz/post/linux_tools/</url><categories/><tags><tag>linux</tag></tags><content type="html"> find - 递归地在层次目录中处理文件 find [path...] [expression] -type b:特殊块文件 缓冲的 c:特殊字符文件 不缓冲 d:目录 p:命名管道 f:普通文件 l:符号链接 s:套接字 //设置递归深度 -maxdepth 1 //在当前目录下搜索 Videos的文件夹 默认递归 find ./ -type d -name "Videos" grep - 打印匹配给定模式的行 grep [options] PATTERN [FILE...] grep [options] [-e PATTERN | -f FILE] [FILE...] -r 递归 -n 在输出的每行前面加上它所在的文件中它的行号 -i 忽略大小写 -I 处理一个二进制文件，但是认为它不包含匹配的内容。 //递归的查找 main 字符串 grep -rn main</content></entry><entry><title>shell脚本用法</title><url>http://rayrain.xyz/post/shell/</url><categories/><tags><tag>linux</tag><tag>shell</tag></tags><content type="html"> 分支 if [[ $1 == 'qd' ]]; then echo '1' elif [[ $1 == 'qi' ]]; then echo '2' elif [[ $1 == 'ob' ]]; then echo '3' else echo 'error' fi 传入参数 使用 $1 $2 $3 $4表示
命令行里的循环 while true ; do ./a.out ; done</content></entry><entry><title>使用qemu启动riscv64 kernel</title><url>http://rayrain.xyz/post/riscv_kernel/</url><categories/><tags><tag>riscv</tag><tag>kernel</tag><tag>qemu</tag></tags><content type="html"> 在这里只是记录一下,方便以后查阅
本文的内容来源
riscv官方网页
解决文件系统问题
编译busybox
9p
获取源码 git clone https://github.com/qemu/qemu git clone https://github.com/torvalds/linux git clone https://git.busybox.net/busybox 编译qemu ./configure --target-list=riscv64-softmmu --enable-virtfs make -j $(nproc) 编译kernel //这里设置的工具链,以自己环境里的为准 //生成配置文件 make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- defconfig //开始编译 make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- -j $(nproc) 编译Busybox make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- defconfig make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- menuconfig //Check Settings - Build static binary (no shared libs) make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- install CONFIG_PREFIX=./rootfs //这里选择将busybox安装到本目录下的./rootfs文件夹下 制作根文件系统 //制作文件系统 $ cd youer_workspace mkdir rootfs $ cd rootfs $ dd if=/dev/zero of=rootfs.img bs=1M count=50 $ mkfs.ext2 -L riscv-rootfs rootfs.img //将它挂载到 mnt/rootfs $ sudo mkdir /mnt/rootfs $ sudo mount rootfs.img /mnt/rootfs //将busybox编译出来的内容复制到rootfs.img文件系统中 $ sudo cp -ar your_busybox/rootfs/* /mnt/rootfs //创建根目录 $ sudo mkdir /mnt/rootfs/{dev,home,mnt,proc,sys,tmp,var} $ sudo chown -R -h root:root /mnt/rootfs //检查文件系统 $ df /mnt/rootfs Filesystem 1K-blocks Used Available Use% Mounted on /dev/loop5 49584 1704 45320 4% /mnt/rootfs $ mount | grep rootfs riscv64-linux/rootfs/rootfs.img on /mnt/rootfs type ext2 (rw,relatime) //卸载文件系统 $ sudo umount /mnt/rootfs $ sudo rmdir /mnt/rootfs 使用根文件系统启动内核 qemu-system-riscv64 -nographic -machine virt \ -kernel linux/arch/riscv/boot/Image -append "root=/dev/vda ro console=ttyS0" \ -drive file=your_rootfs.img,format=raw,id=hd0 \ -device virtio-blk-device,drive=hd0</content></entry><entry><title>C语言运算符优先级</title><url>http://rayrain.xyz/post/c_order/</url><categories/><tags><tag>C</tag><tag>CPP</tag></tags><content type="html"> 优先级 运算符 名称或含义 使用形式 结合方向 说明 1 [] 数组下标 数组名[常量表达式] 左到右 &ndash; () 圆括号 (表达式）/函数名(形参表) &ndash; . 成员选择（对象） 对象.成员名 &ndash; -> 成员选择（指针） 对象指针->成员名 &ndash; 2 - 负号运算符 -表达式 右到左 单目运算符 ~ 按位取反运算符 ~表达式 单目运算符 ++ 自增运算符 ++变量名/变量名++ 单目运算符 &ndash; 自减运算符 &ndash;变量名/变量名&ndash; 单目运算符 ***** 取值运算符 *指针变量 单目运算符 &amp; 取地址运算符 &amp;变量名 单目运算符 ! 逻辑非运算符 !表达式 单目运算符 (类型) 强制类型转换 (数据类型)表达式&ndash; &ndash; sizeof 长度运算符 sizeof(表达式) &ndash; 3 / 除 表达式/表达式 左到右 双目运算符 ***** 乘 表达式*表达式 双目运算符 % 余数（取模） 整型表达式%整型表达式 双目运算符 4 + 加 表达式+表达式 左到右 双目运算符 - 减 表达式-表达式 双目运算符 5 &laquo; 左移 变量&laquo;表达式 左到右 双目运算符 &raquo; 右移 变量&raquo;表达式 双目运算符 6 > 大于 表达式>表达式 左到右 双目运算符 >= 大于等于 表达式>=表达式 双目运算符 &lt; 小于 表达式&lt;表达式 双目运算符 &lt;= 小于等于 表达式&lt;=表达式 双目运算符 7 == 等于 表达式==表达式 左到右 双目运算符 ！= 不等于 表达式!= 表达式 双目运算符 8 &amp; 按位与 表达式&amp;表达式 左到右 双目运算符 9 ^ 按位异或 表达式^表达式 双目运算符 10 | 按位或 表达式|表达式 双目运算符 11 &amp;&amp; 逻辑与 表达式&amp;&amp;表达式 双目运算符 12 || 逻辑或 表达式||表达式 双目运算符 13 ?: 条件运算符 表达式1?表达式2: 表达式3 右到左 三目运算符 14 = 赋值运算符 变量=表达式 右到左 &ndash; /= 除后赋值 变量/=表达式 &ndash; *= 乘后赋值 变量*=表达式 &ndash; %= 取模后赋值 变量%=表达式 &ndash; += 加后赋值 变量+=表达式 &ndash; -= 减后赋值 变量-=表达式 &ndash; &laquo;= 左移后赋值 变量&laquo;=表达式 &ndash; &raquo;= 右移后赋值 变量&raquo;=表达式 &ndash; &amp;= 按位与后赋值 变量&amp;=表达式 &ndash; ^= 按位异或后赋值 变量^=表达式 &ndash; |= 按位或后赋值 变量|=表达式 &ndash; 15 ， 逗号运算符 表达式,表达式,… 左到右 &ndash; 说明：
同一优先级的运算符，运算次序由结合方向所决定。 简单记就是：！ > 算术运算符 > 关系运算符 > &amp;&amp; > || > 赋值运算符</content></entry><entry><title>qemu梳理(riscv64用户模式)</title><url>http://rayrain.xyz/post/qemu0/</url><categories/><tags><tag>qemu</tag></tags><content type="html"> 函数执行流程 main cpu_loop cpu_exec tb_gen_code gen_intermediate_code translator_loop riscv_tr_translate_insn decode_opc decode_insn16 trans_add(/target/riscv/insn_trans/trans_rvi.c.inc) gen_arith(/target/riscv/translate.c) decode文件的内容和用途 从上到下的顺序,是:
Fields字段 # Fields: %rs3 27:5 %rs2 20:5 %rs1 15:5 %rd 7:5 %sh5 20:5 %sh6 20:6 表示参与指令的rs和rd在编码中的位置
immediate立即数 # immediates: %imm_i 20:s12 %imm_s 25:s7 7:5 %imm_b 31:s1 7:1 25:6 8:4 !function=ex_shift_1 %imm_j 31:s1 12:8 20:1 21:10 !function=ex_shift_1 %imm_u 12:s20 !function=ex_shift_12 和Fields作用差不多,表示各种立即数在指令编码中的位置
Argument sets参数集 &amp;empty &amp;b imm rs2 rs1 &amp;i imm rs1 rd &amp;j imm rd 表示每一种类型的指令编码中 参与的立即数和寄存器
python脚本会根据这些生成对应的结构体,如:
typedef struct { } arg_empty; typedef struct { int imm; int rs1; int rd; } arg_i; typedef struct { int imm; int rd; } arg_j; Formats指令格式 # Formats 32: @r ....... ..... ..... ... ..... ....... &amp;r %rs2 %rs1 %rd @i ............ ..... ... ..... ....... &amp;i imm=%imm_i %rs1 %rd @b ....... ..... ..... ... ..... ....... &amp;b imm=%imm_b %rs2 %rs1 @s ....... ..... ..... ... ..... ....... &amp;s imm=%imm_s %rs2 %rs1 @u .................... ..... ....... &amp;u imm=%imm_u %rd @j .................... ..... ....... &amp;j imm=%imm_j %rd 每行都是32个. 表示指令的编码格式
用空格将每部分分开
最后面的是 寄存器 和 立即数 等,它们的字段在上文中已确认
详细的指令集 这部分基本上就是把指令集从官方文档中搬了过来,
python脚本会根据这些指令生成trans_xxx的函数声明,具体的函数定义需要自己编写.
宏 MAKE_64BIT_MASK 位于/include/qemu/bitops.h
#define MAKE_64BIT_MASK(shift, length) \ (((~0ULL) >> (64 - (length))) &lt;&lt; (shift)) 0ULL: unsinged long long zero 64-bit的无符号0
作用:制造一个64位的掩码,该掩码从第shift位开始,长度是length,如下:
0000 ....0 11 .... .111 0.... 000 |--length--|--shift---| FIELD 位于/include/hw/registerfields.h
#define FIELD(reg, field, shift, length) \ enum { R_ ## reg ## _ ## field ## _SHIFT = (shift)}; \ enum { R_ ## reg ## _ ## field ## _LENGTH = (length)}; \ enum { R_ ## reg ## _ ## field ## _MASK = \ MAKE_64BIT_MASK(shift, length)}; 这个宏定义了三个枚举 ,各自只有一个成员
R_reg_field_SHIFT = shift
R_reg_field_LENGTH = length
R_reg_field_MASK = 对应length和shift的掩码
重要的结构体 CPUArchState(某个arch的cpu状态) 根据不同的guest,会被定义为其它名称,如:CPURISCVState
事实上,CPUArchState 被定义于 target/riscv/cpu.h, 每种guest的这个结构体都不一样
struct CPUArchState { target_ulong gpr[32]; //32个gpr寄存器,每个寄存器长32 target_ulong gprh[32]; /* 128-bit寄存器的高64位,每个寄存器长32 */ uint64_t fpr[32]; //32个浮点寄存器 /* assume both F and D extensions */ /* vector coprocessor state. */ uint64_t vreg[32 * RV_VLEN_MAX / 64] QEMU_ALIGNED(16); target_ulong vxrm; target_ulong vxsat; target_ulong vl; target_ulong vstart; target_ulong vtype; bool vill; target_ulong pc; target_ulong load_res; target_ulong load_val; target_ulong frm; target_ulong badaddr; uint32_t bins; target_ulong guest_phys_fault_addr; target_ulong priv_ver; target_ulong bext_ver; target_ulong vext_ver; /* RISCVMXL, but uint32_t for vmstate migration */ uint32_t misa_mxl; /* current mxl */ uint32_t misa_mxl_max; /* max mxl for this cpu */ uint32_t misa_ext; /* current extensions */ uint32_t misa_ext_mask; /* max ext for this cpu */ uint32_t xl; /* current xlen */ /* 128-bit helpers upper part return value */ target_ulong retxh; uint32_t features; #ifdef CONFIG_USER_ONLY uint32_t elf_flags; #endif #ifndef CONFIG_USER_ONLY target_ulong priv; /* This contains QEMU specific information about the virt state. */ target_ulong virt; target_ulong geilen; target_ulong resetvec; target_ulong mhartid; /* * For RV32 this is 32-bit mstatus and 32-bit mstatush. * For RV64 this is a 64-bit mstatus. */ uint64_t mstatus; uint64_t mip; uint64_t miclaim; uint64_t mie; uint64_t mideleg; target_ulong satp; /* since: priv-1.10.0 */ target_ulong stval; target_ulong medeleg; target_ulong stvec; target_ulong sepc; target_ulong scause; target_ulong mtvec; target_ulong mepc; target_ulong mcause; target_ulong mtval; /* since: priv-1.10.0 */ /* Machine and Supervisor interrupt priorities */ uint8_t miprio[64]; uint8_t siprio[64]; /* AIA CSRs */ target_ulong miselect; target_ulong siselect; /* Hypervisor CSRs */ target_ulong hstatus; target_ulong hedeleg; uint64_t hideleg; target_ulong hcounteren; target_ulong htval; target_ulong htinst; target_ulong hgatp; target_ulong hgeie; target_ulong hgeip; uint64_t htimedelta; /* Hypervisor controlled virtual interrupt priorities */ target_ulong hvictl; uint8_t hviprio[64]; /* Upper 64-bits of 128-bit CSRs */ uint64_t mscratchh; uint64_t sscratchh; /* Virtual CSRs */ /* * For RV32 this is 32-bit vsstatus and 32-bit vsstatush. * For RV64 this is a 64-bit vsstatus. */ uint64_t vsstatus; target_ulong vstvec; target_ulong vsscratch; target_ulong vsepc; target_ulong vscause; target_ulong vstval; target_ulong vsatp; /* AIA VS-mode CSRs */ target_ulong vsiselect; target_ulong mtval2; target_ulong mtinst; /* HS Backup CSRs */ target_ulong stvec_hs; target_ulong sscratch_hs; target_ulong sepc_hs; target_ulong scause_hs; target_ulong stval_hs; target_ulong satp_hs; uint64_t mstatus_hs; /* Signals whether the current exception occurred with two-stage address translation active. */ bool two_stage_lookup; target_ulong scounteren; target_ulong mcounteren; target_ulong sscratch; target_ulong mscratch; /* temporary htif regs */ uint64_t mfromhost; uint64_t mtohost; uint64_t timecmp; /* physical memory protection */ pmp_table_t pmp_state; target_ulong mseccfg; /* machine specific rdtime callback */ uint64_t (*rdtime_fn)(uint32_t); uint32_t rdtime_fn_arg; /* machine specific AIA ireg read-modify-write callback */ #define AIA_MAKE_IREG(__isel, __priv, __virt, __vgein, __xlen) \ ((((__xlen) &amp; 0xff) &lt;&lt; 24) | \ (((__vgein) &amp; 0x3f) &lt;&lt; 20) | \ (((__virt) &amp; 0x1) &lt;&lt; 18) | \ (((__priv) &amp; 0x3) &lt;&lt; 16) | \ (__isel &amp; 0xffff)) #define AIA_IREG_ISEL(__ireg) ((__ireg) &amp; 0xffff) #define AIA_IREG_PRIV(__ireg) (((__ireg) >> 16) &amp; 0x3) #define AIA_IREG_VIRT(__ireg) (((__ireg) >> 18) &amp; 0x1) #define AIA_IREG_VGEIN(__ireg) (((__ireg) >> 20) &amp; 0x3f) #define AIA_IREG_XLEN(__ireg) (((__ireg) >> 24) &amp; 0xff) int (*aia_ireg_rmw_fn[4])(void *arg, target_ulong reg, target_ulong *val, target_ulong new_val, target_ulong write_mask); void *aia_ireg_rmw_fn_arg[4]; /* True if in debugger mode. */ bool debugger; /* * CSRs for PointerMasking extension */ target_ulong mmte; target_ulong mpmmask; target_ulong mpmbase; target_ulong spmmask; target_ulong spmbase; target_ulong upmmask; target_ulong upmbase; #endif target_ulong cur_pmmask; target_ulong cur_pmbase; float_status fp_status; /* Fields from here on are preserved across CPU reset. */ QEMUTimer *timer; /* Internal timer */ hwaddr kernel_addr; hwaddr fdt_addr; /* kvm timer */ bool kvm_timer_dirty; uint64_t kvm_timer_time; uint64_t kvm_timer_compare; uint64_t kvm_timer_state; uint64_t kvm_timer_frequency; }; CPUState(通用上的CPU状态) 里面会保存tb缓存
struct CPUState { /*&lt; private >*/ DeviceState parent_obj; /*&lt; public >*/ int nr_cores; int nr_threads; struct QemuThread *thread; #ifdef _WIN32 HANDLE hThread; #endif int thread_id; bool running, has_waiter; struct QemuCond *halt_cond; bool thread_kicked; bool created; bool stop; bool stopped; /* Should CPU start in powered-off state? */ bool start_powered_off; bool unplug; bool crash_occurred; bool exit_request; bool in_exclusive_context; uint32_t cflags_next_tb; /* updates protected by BQL */ uint32_t interrupt_request; int singlestep_enabled; int64_t icount_budget; int64_t icount_extra; uint64_t random_seed; sigjmp_buf jmp_env; QemuMutex work_mutex; QSIMPLEQ_HEAD(, qemu_work_item) work_list; CPUAddressSpace *cpu_ases; int num_ases; AddressSpace *as; MemoryRegion *memory; CPUArchState *env_ptr; IcountDecr *icount_decr_ptr; /* Accessed in parallel; all accesses must be atomic */ TranslationBlock *tb_jmp_cache[TB_JMP_CACHE_SIZE]; struct GDBRegisterState *gdb_regs; int gdb_num_regs; int gdb_num_g_regs; QTAILQ_ENTRY(CPUState) node; /* ice debug support */ QTAILQ_HEAD(, CPUBreakpoint) breakpoints; QTAILQ_HEAD(, CPUWatchpoint) watchpoints; CPUWatchpoint *watchpoint_hit; void *opaque; /* In order to avoid passing too many arguments to the MMIO helpers, * we store some rarely used information in the CPU context. */ uintptr_t mem_io_pc; /* Only used in KVM */ int kvm_fd; struct KVMState *kvm_state; struct kvm_run *kvm_run; struct kvm_dirty_gfn *kvm_dirty_gfns; uint32_t kvm_fetch_index; uint64_t dirty_pages; /* Used for events with 'vcpu' and *without* the 'disabled' properties */ DECLARE_BITMAP(trace_dstate_delayed, CPU_TRACE_DSTATE_MAX_EVENTS); DECLARE_BITMAP(trace_dstate, CPU_TRACE_DSTATE_MAX_EVENTS); DECLARE_BITMAP(plugin_mask, QEMU_PLUGIN_EV_MAX); #ifdef CONFIG_PLUGIN GArray *plugin_mem_cbs; /* saved iotlb data from io_writex */ SavedIOTLB saved_iotlb; #endif /* TODO Move common fields from CPUArchState here. */ int cpu_index; int cluster_index; uint32_t tcg_cflags; uint32_t halted; uint32_t can_do_io; int32_t exception_index; /* shared by kvm, hax and hvf */ bool vcpu_dirty; /* Used to keep track of an outstanding cpu throttle thread for migration * autoconverge */ bool throttle_thread_scheduled; bool ignore_memory_transaction_failures; /* Used for user-only emulation of prctl(PR_SET_UNALIGN). */ bool prctl_unalign_sigbus; struct hax_vcpu_state *hax_vcpu; struct hvf_vcpu_state *hvf; /* track IOMMUs whose translations we've cached in the TCG TLB */ GArray *iommu_notifiers; }; ArchCPU 每一种arc都有一个这样的结构体,包含了上面两个结构体
struct ArchCPU { /*&lt; private >*/ CPUState parent_obj; /*&lt; public >*/ CPUNegativeOffsetState neg; CPURISCVState env; char *dyn_csr_xml; char *dyn_vreg_xml; /* Configuration Settings */ RISCVCPUConfig cfg; }; 函数 env_cpu 在cpu_loop函数中调用
/** * env_archcpu(env) * @env: The architecture environment * * Return the ArchCPU associated with the environment. */ static inline ArchCPU *env_archcpu(CPUArchState *env) { return container_of(env, ArchCPU, env); } 这个函数用于获取当前环境env的对应的CPUState
随便写写 关于tb寻找和生成 cpu_exec函数,是主循环,在没发生异常和中断的情况下会一直执行tb块
首先会使用tb_lookup在缓存中根据pc值等参数在缓存中寻找下一个tb块
如果没找到,就会根据相同的参数生成新的tb块</content></entry><entry><title>VIM技巧(持续更新)</title><url>http://rayrain.xyz/post/vim/</url><categories/><tags><tag>vim</tag></tags><content type="html"> 简单记录一下vim的技巧
打开nerdtree 目录 命令行下:
vim ./ vim中:
:e %:h //打开当前文件所在目录 :e ./ //貌似这样也可以 在nerdtree目录下 s //默认打开一个垂直的分割窗口 t //打开一个新的tab窗口 操作tab page gt //默认移动到下一个tab 1gt //打开第一个tab 2gt //打开第二个tab 操作分割窗口 :sp //横向打开分割窗口 :vsp //垂直打开分割窗口 ctrl w + 方向键 //在分割窗口之间移动 内置grep搜索 :vim[grep][!] /{pattern}/[g][j] {file} ... :vim[grep][!] {pattern} {file} ... vimgrep可以简写为vim 举例
在当前目录下的linux-user文件夹下 的c文件中搜索 main( 字符串 :vimgrep main( ./linux-user/*.c 在当前目录下递归寻找 :vimgrep main( ./**/*.c 更多
:cnext, :cn # 当前页下一个结果 :cprevious, :cp # 当前页上一个结果 :clist, :cl # 使用 more 打开 Quickfix 窗口 :copen, :cope, :cw # 打开 Quickfix 窗口，列出所有结果 :ccl[ose] # 关闭 Quickfix 窗口。 lvimgrep 命令 lvimgrep 与 vimgrep 搜索命令基本一样，不同点在于搜索结果不是显示在 Quickfix 中而是显示在 location-list 中 移动 使用大括号在空行之间移动
迅速查找字符串 将光标移动到字符串上然后输入
shift + 8 Ctags使用 生成tags 数据库文件
ctags -R . //递归生成当前根目录的tags文件 vim可以自动匹配tags文件
使用:
ctrl + ] //跳转到定义处 ctrl + T //返回到跳转前的位置 ctrl + W + ] //分割当前窗口,并在新窗口中显示跳转到的定义 ctrl + O //返回之前的位置 :ts //列出所有匹配的标签 CScope使用 生成数据库文件
cscope -Rbq 在vim中:
cscope 命令:(以下都已:cs开头) add : 添加一个新的数据库 (Usage: add file|dir [pre-path] [flags]) find : 查询一个模式 (Usage: find a|c|d|e|f|g|i|s|t name) a: Find assignments to this symbol c: Find functions calling this function d: Find functions called by this function 查找被这个函数调用的函数 e: Find this egrep pattern f: Find this file 查找这个文件 g: Find this definition 查找定义 i: Find files #including this file 查找include了这个文件的所有文件 s: Find this C symbol 查找C符号 t: Find this text string 查找这个文本字符串 help : 显示此信息 (Usage: help) kill : 结束一个连接 (Usage: kill #) reset: 重置所有连接 (Usage: reset) show : 显示连接 (Usage: show) :s替换字符串 :s/helllo/sky/ 替换当前行第一个hello为sky :s/helllo/sky/g 替换当前行的所有hello为sky :n,$s/hello/sky 替换第n行开始到最后一行的第一个hello为sky :n,$s/hello/sky/g 替换第n行开始到最后一行的所有hello为sky :%s/hello/sky 替换每一行的第一个hello为sky :%s/hello/sky/g 替换每一行的所有hello为sky 寄存器 访问寄存器 "registers 正则表达式 全字搜索
/\&lt;word\></content></entry><entry><title>从ELF谈起</title><url>http://rayrain.xyz/post/elf/</url><categories/><tags><tag>elf</tag><tag>linux</tag></tags><content type="html"> 本文信息来源:
又是一期硬核内容：ELF文件格式
What&rsquo;s the difference of section and segment in ELF file format
ELF Sections &amp; Segments and Linux VMA Mappings
ELF简介 ELF全称 executable and linkable format 精灵
是一种linux下常用的可执行文件 对象 共享库的标准文件格式
还有许多其他可执行文件格式 PE Mach-O COFF COM
内核中处理elf相关代码参考: binfmt_elf.c
elf中的数据按照Segment(段)和Section(节)两个概念进行划分
ELF文件格式 ELF Header 架构 ABI版本等基础信息 program header table的位置和数量 section header table的位置和数量 Program header table 每个表项定义了一个segment 每个segment可包含多个section Section header table 每个表项定义了一个section readelf命令 可用readelf命令来展示elf文件的相关信息
用法如下:
用法：readelf &lt;选项> elf-文件 显示关于 ELF 格式文件内容的信息 Options are: -a --all Equivalent to: -h -l -S -s -r -d -V -A -I -h --file-header Display the ELF file header -l --program-headers Display the program headers --segments An alias for --program-headers -S --section-headers Display the sections' header --sections An alias for --section-headers -g --section-groups Display the section groups -t --section-details Display the section details -e --headers Equivalent to: -h -l -S 比如,使用readelf来查看date的信息
readelf -l /bin/date 输出
Elf 文件类型为 DYN (Position-Independent Executable file) Entry point 0x38c0 There are 13 program headers, starting at offset 64 程序头： Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align PHDR 0x0000000000000040 0x0000000000000040 0x0000000000000040 0x00000000000002d8 0x00000000000002d8 R 0x8 INTERP 0x0000000000000318 0x0000000000000318 0x0000000000000318 0x000000000000001c 0x000000000000001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x00000000000028a8 0x00000000000028a8 R 0x1000 LOAD 0x0000000000003000 0x0000000000003000 0x0000000000003000 0x0000000000010001 0x0000000000010001 R E 0x1000 LOAD 0x0000000000014000 0x0000000000014000 0x0000000000014000 0x0000000000005cf0 0x0000000000005cf0 R 0x1000 LOAD 0x0000000000019ff0 0x000000000001aff0 0x000000000001aff0 0x00000000000010b0 0x0000000000001268 RW 0x1000 DYNAMIC 0x000000000001ab98 0x000000000001bb98 0x000000000001bb98 0x00000000000001f0 0x00000000000001f0 RW 0x8 NOTE 0x0000000000000338 0x0000000000000338 0x0000000000000338 0x0000000000000040 0x0000000000000040 R 0x8 NOTE 0x0000000000000378 0x0000000000000378 0x0000000000000378 0x0000000000000044 0x0000000000000044 R 0x4 GNU_PROPERTY 0x0000000000000338 0x0000000000000338 0x0000000000000338 0x0000000000000040 0x0000000000000040 R 0x8 GNU_EH_FRAME 0x0000000000018000 0x0000000000018000 0x0000000000018000 0x0000000000000454 0x0000000000000454 R 0x4 GNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 RW 0x10 GNU_RELRO 0x0000000000019ff0 0x000000000001aff0 0x000000000001aff0 0x0000000000001010 0x0000000000001010 R 0x1 Section to Segment mapping: 段节... 00 01 .interp 02 .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 03 .init .plt .text .fini 04 .rodata .eh_frame_hdr .eh_frame 05 .init_array .fini_array .data.rel.ro .dynamic .got .data .bss 06 .dynamic 07 .note.gnu.property 08 .note.gnu.build-id .note.ABI-tag 09 .note.gnu.property 10 .eh_frame_hdr 11 12 .init_array .fini_array .data.rel.ro .dynamic .got 可知:
在加载到内存中时,程序被分成了13个Segment(从PHDR到GNU_RELRO) 每个Segment都包含了1个或者更多的Section Segment vs Section Segment 包含着运行时需要的信息
用于告诉操作系统,段应该被加载到虚拟内存中的什么位置?每个段都有那些权限?(read, write, execute)
每个Segment主要包含加载地址 文件中的范围 内存权限 对齐方式等信息
Section 包含着链接时需要的信息
用于告诉链接器,elf中每个部分是什么,哪里是代码,哪里是只读数据,哪里是重定位信息
每个Section主要包含Section类型 文件中的位置 大小等信息
链接器会把Section放入Segment中
Segment和Section的关系 相同权限的Section会放入同一个Segment,例如.text和.rodata section 一个Segment包含许多Section,一个Section可以属于多个Segment 链接脚本 运行
ld --verbose 可以看到本系统中所用的脚本
我的Archlinux 5.16.13-arch1-1的链接脚本一部分是这样:
.gnu.version_r : { *(.gnu.version_r) } .rela.dyn : { *(.rela.init) *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) *(.rela.fini) *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) *(.rela.ctors) *(.rela.dtors) *(.rela.got) *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*) *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*) *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*) *(.rela.ifunc) } 表示:
.gnu.version_r Section 会被放入 .gnu.version_r Segment
.rela.init等一大堆的Section,会被放入 .rela.dyn Segment
汇编中的伪指令全部都是Section,要等链接之后才会有Segment
NASM中 .section 和.segment 这两个是等效的,都表示 Section
ELF文件分类 可执行文件(ET_EXEC) 可直接运行的程序,必须包含segment
对象文件(ET_REL,*.o) 需要与其他对象文件链接,必须包含section
动态库(ET_DYN,*.so) 与其他对象文件/可执行文件链接
必须同时包含segment和section
ELF的内存映射 查看内存映射情况 cat /proc/[pid]/maps 比如运行
cat /proc/self/maps 查看cat本身的内存映射
563b04d75000-563b04d77000 r--p 00000000 fe:00 6294104 /usr/bin/cat 563b04d77000-563b04d7c000 r-xp 00002000 fe:00 6294104 /usr/bin/cat 563b04d7c000-563b04d7f000 r--p 00007000 fe:00 6294104 /usr/bin/cat 563b04d7f000-563b04d80000 r--p 00009000 fe:00 6294104 /usr/bin/cat 563b04d80000-563b04d81000 rw-p 0000a000 fe:00 6294104 /usr/bin/cat 563b058b6000-563b058d7000 rw-p 00000000 00:00 0 [heap] 7f5f7324b000-7f5f73837000 r--p 00000000 fe:00 6364075 /usr/lib/locale/locale-archive 7f5f73837000-7f5f7383a000 rw-p 00000000 00:00 0 7f5f7383a000-7f5f73866000 r--p 00000000 fe:00 6294921 /usr/lib/libc.so.6 7f5f73866000-7f5f739dc000 r-xp 0002c000 fe:00 6294921 /usr/lib/libc.so.6 7f5f739dc000-7f5f73a30000 r--p 001a2000 fe:00 6294921 /usr/lib/libc.so.6 7f5f73a30000-7f5f73a31000 ---p 001f6000 fe:00 6294921 /usr/lib/libc.so.6 7f5f73a31000-7f5f73a34000 r--p 001f6000 fe:00 6294921 /usr/lib/libc.so.6 7f5f73a34000-7f5f73a37000 rw-p 001f9000 fe:00 6294921 /usr/lib/libc.so.6 7f5f73a37000-7f5f73a46000 rw-p 00000000 00:00 0 7f5f73a70000-7f5f73a92000 rw-p 00000000 00:00 0 7f5f73a92000-7f5f73a94000 r--p 00000000 fe:00 6294911 /usr/lib/ld-linux-x86-64.so.2 7f5f73a94000-7f5f73abb000 r-xp 00002000 fe:00 6294911 /usr/lib/ld-linux-x86-64.so.2 7f5f73abb000-7f5f73ac6000 r--p 00029000 fe:00 6294911 /usr/lib/ld-linux-x86-64.so.2 7f5f73ac7000-7f5f73ac9000 r--p 00034000 fe:00 6294911 /usr/lib/ld-linux-x86-64.so.2 7f5f73ac9000-7f5f73acb000 rw-p 00036000 fe:00 6294911 /usr/lib/ld-linux-x86-64.so.2 7ffec90a6000-7ffec90c8000 rw-p 00000000 00:00 0 [stack] 7ffec918d000-7ffec9191000 r--p 00000000 00:00 0 [vvar] 7ffec9191000-7ffec9193000 r-xp 00000000 00:00 0 [vdso] ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0 [vsyscall] 从左到右为:
虚拟地址的起始和结束 该内存映射的类型flag r(read) w(write) x(execute) p(private) s(shared) 实际对象在该内存映射上相对于起始的偏移量 major:minor: the major and minor number pairs of the device holding the file that has been mapped. 映射文件的索引节点号码 该内存映射文件的名称</content></entry><entry><title>关于我</title><url>http://rayrain.xyz/about.html</url><categories/><tags/><content type="html"> a righteoux</content></entry></search>