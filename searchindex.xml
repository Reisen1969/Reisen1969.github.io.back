<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>lua note</title><url>http://rayrain.xyz/post/lua/</url><categories/><tags><tag>lua</tag></tags><content type="html"> lua简介 lua是一门嵌入式的脚本语言,其存在的意义就是给C/C++等高级语言打下手,当一个好配角.
对于C/C++来说,lua的作用主要体现在:在C/C++程序没有重新编译,甚至没有重启的情况下,只通过改变lua脚本的内容,令C/C++程序做出不一样的行为.
一些有用的链接:
lua菜鸟教程
lua5.3官方手册
lua程序设计
lua实际上是一个库,命令行里的可交互程序luac是lua库的副产物,只有400多行,很少用到.
lua可以嵌入到C程序里,但lua和C是两个完全不一样的世界,lua中的变量只能由lua管理,C语言中的值lua也不知道,双方只能通过一个虚拟栈来交换信息.C和lua之间也主要是围绕着"lua虚拟栈" &ldquo;lua环境&rdquo; &ldquo;C环境&rdquo; 编程的.
本文中出现的lua API不一定全部解释,请查阅lua5.3官方手册
创建一个lua对象 lua_State *L = luaL_newstate(); lua虚拟栈 lua虚拟栈是这样的--> | 栈顶 | 索引值:-1 -------- | | ------- | 栈底 | 索引值:1 ------- 和一般的栈没有什么不同的 栈基本操作 //取出栈顶的元素,赋给全局变量,可以新建全局变量 LUA_API void (lua_setglobal) (lua_State *L, const char *name); //idx[k] = v v是索引-1处的值 , k是索引-2的值 //并将k和v 弹出堆栈 这个函数可以触发__newindex元方法 LUA_API void (lua_settable) (lua_State *L, int idx); //如果idx处是个table,弹出栈顶的元素 赋值给改table[k],k必须为字符串 LUA_API void (lua_setfield) (lua_State *L, int idx, const char *k); LUA_API void (lua_seti) (lua_State *L, int idx, lua_Integer n); //跟lua_settable一样 不会调用元方法 LUA_API void (lua_rawset) (lua_State *L, int idx); LUA_API void (lua_rawseti) (lua_State *L, int idx, lua_Integer n); LUA_API void (lua_rawsetp) (lua_State *L, int idx, const void *p); //从堆栈中弹出一个表，并将其设置为给定索引值objindex的新元表 LUA_API int (lua_setmetatable) (lua_State *L, int objindex); LUA_API void (lua_setuservalue) (lua_State *L, int idx); stack&ndash;>C //索引处是否是数字或可转换成数字的字符串 LUA_API int (lua_isnumber) (lua_State *L, int idx); //索引处 是否是字符串 或者可转换成字符串的数字 LUA_API int (lua_isstring) (lua_State *L, int idx); LUA_API int (lua_iscfunction) (lua_State *L, int idx); LUA_API int (lua_isinteger) (lua_State *L, int idx); LUA_API int (lua_isuserdata) (lua_State *L, int idx); LUA_API int (lua_type) (lua_State *L, int idx); LUA_API const char *(lua_typename) (lua_State *L, int tp); LUA_API lua_Number (lua_tonumberx) (lua_State *L, int idx, int *isnum); LUA_API lua_Integer (lua_tointegerx) (lua_State *L, int idx, int *isnum); LUA_API int (lua_toboolean) (lua_State *L, int idx); LUA_API const char *(lua_tolstring) (lua_State *L, int idx, size_t *len); LUA_API size_t (lua_rawlen) (lua_State *L, int idx); LUA_API lua_CFunction (lua_tocfunction) (lua_State *L, int idx); LUA_API void *(lua_touserdata) (lua_State *L, int idx); LUA_API lua_State *(lua_tothread) (lua_State *L, int idx); LUA_API const void *(lua_topointer) (lua_State *L, int idx); C&ndash;>stack //向栈中推入一个nil LUA_API void (lua_pushnil) (lua_State *L); //向栈中推入一个double数字 LUA_API void (lua_pushnumber) (lua_State *L, lua_Number n); //推入longlong数字 LUA_API void (lua_pushinteger) (lua_State *L, lua_Integer n); //推入字符串的前len个元素 LUA_API const char *(lua_pushlstring) (lua_State *L, const char *s, size_t len); //推入字符串 LUA_API const char *(lua_pushstring) (lua_State *L, const char *s); //va_list用法 LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,va_list argp); //推入格式化输出的字符串 LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...); //推入闭包 LUA_API void (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n); //推入布尔值 LUA_API void (lua_pushboolean) (lua_State *L, int b); //推入用户数据 LUA_API void (lua_pushlightuserdata) (lua_State *L, void *p); LUA_API int (lua_pushthread) (lua_State *L); lua&ndash;>stack //将存在的全局变量压入栈顶 LUA_API int (lua_getglobal) (lua_State *L, const char *name); //将存在的table 压入栈顶lua_setmetatable LUA_API int (lua_gettable) (lua_State *L, int idx); //如果idx索引处是table,将该table[k]放到栈顶,k必须为字符串 LUA_API int (lua_getfield) (lua_State *L, int idx, const char *k); LUA_API int (lua_geti) (lua_State *L, int idx, lua_Integer n); LUA_API int (lua_rawget) (lua_State *L, int idx); //将t[n]压入堆栈,t是索引idx处的表,不会调用__index元方法 LUA_API int (lua_rawgeti) (lua_State *L, int idx, lua_Integer n); LUA_API int (lua_rawgetp) (lua_State *L, int idx, const void *p); //创建一个空的table并压入栈中，并预分配narr个array元素的空间和预分配nrec个非array元素的空间 LUA_API void (lua_createtable) (lua_State *L, int narr, int nrec); //这个函数以给定的大小分配一个新的内存块，将一个新的完整的用户数据和块地址压入堆栈，并返回这个地址。主机程序可以自由地使用这些内存 LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz); LUA_API int (lua_getmetatable) (lua_State *L, int objindex); LUA_API int (lua_getuservalue) (lua_State *L, int idx); //如果idx处是一个table,获取该table的fname索引,并压入栈顶 LUALIB_API int (luaL_getsubtable) (lua_State *L, int idx, const char *fname); stack&ndash;>lua //取出栈顶的元素,赋给全局变量,可以新建全局变量 LUA_API void (lua_setglobal) (lua_State *L, const char *name); //idx[k] = v v是索引-1处的值 , k是索引-2的值 //并将k和v 弹出堆栈 这个函数可以触发__newindex元方法 LUA_API void (lua_settable) (lua_State *L, int idx); //如果idx处是个table,弹出栈顶的元素 赋值给改table[k],k必须为字符串 LUA_API void (lua_setfield) (lua_State *L, int idx, const char *k); LUA_API void (lua_seti) (lua_State *L, int idx, lua_Integer n); //跟lua_settable一样 不会调用元方法 LUA_API void (lua_rawset) (lua_State *L, int idx); LUA_API void (lua_rawseti) (lua_State *L, int idx, lua_Integer n); LUA_API void (lua_rawsetp) (lua_State *L, int idx, const void *p); //从堆栈中弹出一个表，并将其设置为给定索引值objindex的新元表 LUA_API int (lua_setmetatable) (lua_State *L, int objindex); LUA_API void (lua_setuservalue) (lua_State *L, int idx); load &amp; call LUA_API void (lua_callk) (lua_State *L, int nargs, int nresults, lua_KContext ctx, lua_KFunction k); #define lua_call(L,n,r) lua_callk(L, (n), (r), 0, NULL) LUA_API int (lua_pcallk) (lua_State *L, int nargs, int nresults, int errfunc, lua_KContext ctx, lua_KFunction k); #define lua_pcall(L,n,r,f) lua_pcallk(L, (n), (r), (f), 0, NULL) LUA_API int (lua_load) (lua_State *L, lua_Reader reader, void *dt, const char *chunkname, const char *mode); LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data, int strip); //加载一个文件并执行 #define luaL_dofile(L, fn) (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0)) 表和元方法 表是lua中用途最广泛的结构,
注册表和引用</content></entry><entry><title>hugo相关操作</title><url>http://rayrain.xyz/post/hugo_manual/</url><categories/><tags><tag>hugo</tag></tags><content type="html"> hugo简单操作
生成仓库中需要的内容 hugo 运行hugo服务器 hugo server push到仓库 git remote add origin git@github.com:Reisen1969/Reisen1969.github.io.git git push origin master</content></entry><entry><title>ygopro源码分析</title><url>http://rayrain.xyz/post/ygopro1/</url><categories/><tags><tag>ygopro</tag></tags><content type="html"> 总览 1.简单介绍 ygopro是一个开源免费的游戏王模拟器,可以模拟几乎所有的游戏王卡片,并且在源码的级别上同时支持windows linux 和macos等操作系统,不过这个项目的创建者Fluorohydride(圆神)从2016年就神隠了,这个项目由一群爱好者一直维护,还有两个主要的对战服务器,233服和萌卡mycard.
本文的读者想必都是决斗者了,一些专有名词就不解释了,默认大家都懂了.
源码由3部分组成,还用了若干的第三方库.
ygopro:游戏的客户端本体 |-irrlicht:游戏引擎,负责游戏画面和GUI |-freetype:字体引擎,负责让irrlicht显示中文 |-sqlite3:轻量级数据库,存储卡片的数据,用于卡片的查找搜寻 |-libevent2:网络库,实现联机对战 |-lzma:压缩算法,用于游戏录像 ocgcore:脚本处理引擎 |-lua5.3:用于读取各种脚本 script:lua编写的卡片脚本 ygopro使用的音频引擎是irrKlang,不开源,我直接选择性忽略了.
我全程在archlinux上分析的源码,文中有关windows的地方我都验证过了
不会分析TAG模式和replay
2.前期准备 2.1 下载源码 git clone --recurse https://github.com/Fluorohydride/ygopro.git 这个命令可以源码的3部分全部下载下来.不包括第三方库.
然后就是编译了,打开文件夹后可以看到本项目似乎支持cmake和premake4.
实际上这个CMakeList文件的编写者是在ubuntu系linux下测试的,如果你使用ubuntu系的linux的话,安装好各种库之后就可以用cmake一键编译了,如果不是的话就往下看吧.
2.2 使用VisualStudio编译 我不太喜欢这个重量级的软件,如果想要用vs编译的话,建议去参考尸体233的Travis CI脚本,按照这个脚本一步步操作,可以生成sln项目文件,然后就能用vs编译了,下面的内容就可以直接跳过去了,直接去看第3节了.
2.3 使用vcpkg管理第三方库 如果你按照上面的操作使用vs编译的话,你需要下载一堆第三方库的源码,然后解压到指定目录,特别麻烦,而且这些库是"一次性"的,所以我推荐使用vcpkg去统一管理这些第三方库,具体使用方法我就不多说了,懂得都懂,官方文档.
我用的linux,自带包管理工具,也需要用vcpkg吗?
如果使用的是非ubuntu系的话,还是建议使用,因为vcpkg可以完美嵌入cmake,如果使用的是自带的包管理工具的话,可能cmake无法find到某个库,头文件路径也可能跟代码有出入,用了vcpkg,这一切就都解决了.
2.4 使用vscode 如果没有选择vs的话,vscode就是最佳选择了,话是这么说,但vs改装还得装,因为编译器msvc是必须的. 需要的vscode插件:C/C++ ,CMake 和CMake Tools.
关于CLion
我使用过一段时间的CLion,它的体验基本上跟vscode一致,但存在一些缺点:
占用资源比较大 多线程调试很差,甚至不如直接用gdb.(这是我遇到的问题,我没找到原因) 2.5 linux上使用cmake+gcc编译 如上面所说,使用vcpkg管理第三方库,嵌入项目自带的CMakeLists文件即可.
具体做法:将原本的第三方库相关内容去掉换成vcpkg
2.6 windows上使用cmake+msvc编译 杂项 游戏配置的读取 ygopro所有的游戏配置都写在文本文件里
lflist.conf 禁卡表文件,包含了所有的禁卡表 strings.conf 在客户端上显示的所有文字 system.conf 一些设置选项 irrlicht irrlicht是一个古老的游戏引擎,网上几乎没有什么中文资料,不过对于ygopro来说,只用了一些简单的图形效果和很复古的GUI,比如下面的程序通过改变卡片的横坐标来表示卡组的洗牌动画
for (auto cit = mainGame->dField.deck[player].begin(); cit != mainGame->dField.deck[player].end(); ++cit) { (*cit)->dPos = irr::core::vector3df(rnd.rand() * 0.4f / rnd.rand_max - 0.2f, 0, 0); (*cit)->dRot = irr::core::vector3df(0, 0, 0); (*cit)->is_moving = true; (*cit)->aniFrame = 3; } 想学习irrlicht的话建议去看官方的Tutorials.
irrlicht写的非常规范,容易阅读,但毕竟十几年前的产物了,并不推荐用这个制作游戏.
I 开头的是 纯虚接口类 C 开头的是 接口实现类 E 是枚举值 S 是结构体 irrlichtr是个3D引擎,想深入学习需要OpenGL或者Direct3D相关的知识.
但是对于ygopro来说,只需要了解下面这两点就可以了
1.irrlicht的初始化操作
首先需要获取一个IrrlichtDevice,这是irrlicht最根本的对象,有两种方法得到
自定义params,也是ygopro使用的方法 IrrlichtDevice* device; irr::SIrrlichtCreationParameters params = irr::SIrrlichtCreationParameters(); //对params做一些自定义 device = irr::createDeviceEx(params); 或者 使用默认params 函数原型: IrrlichtDevice* createDevice( video::E_DRIVER_TYPE deviceType = video::EDT_SOFTWARE, const core::dimension2d&lt;u32>&amp; windowSize = (core::dimension2d&lt;u32>(640,480)), u32 bits = 16, bool fullscreen = false, bool stencilbuffer = false, bool vsync = false, IEventReceiver* receiver = 0); 使用IrrlichtDevice获取其他对象
获取IVideoDriver,所有图形相关的接口 IVideoDriver* driver = device->getVideoDriver(); 获取IGUIEnvironment,用于管理所有GUI组件 IGUIEnvironment* env = device->getGUIEnvironment(); 获取ISceneManager,管理camera 等其他资源 ISceneManager* smgr = device->getSceneManager(); 主循环
while(device->run()) { //绘制GUI 绘制图形 //接收玩家输入等 } 2.GUI相关
irrlicht的GUI还是比较落后的.ygopro用了七八百行,来添加GUI元素
添加GUI的步骤
首先去要预先定义一些宏来表示GUI的id(类似QT里的信号),如: #define BUTTON_LAN_MODE 100 #define BUTTON_SINGLE_MODE 101 #define BUTTON_REPLAY_MODE 102 #define BUTTON_TEST_MODE 103 添加btn btnLanMode = env->addButton(rect&lt;s32>(10, 30, 270, 60), wMainMenu, BUTTON_LAN_MODE, dataManager.GetSysString(1200)); 添加checkbox chkHostPrepReady[i] = env->addCheckBox(false, rect&lt;s32>(250, 75 + i * 25, 270, 95 + i * 25), wHostPrepare, CHECKBOX_HP_READY, L""); 初始化这些元素时都有一个参数是id,当GUI元素被操作的时候这些id就代表了不同的信号. 如何使用GUI
需要一个对象来接受这些信号,从而使这些GUI元素发挥作用.在irrlicht里,这个对象被称为EventReceiver.
同一时刻,一个device只能有一个EventReceiver.
这行程序为device设置了一个EventReceiver device->setEventReceiver(&amp;menuHandler); 任意一个类,只要重写了OnEvent(const irr::SEvent&amp; event)方法,就可以成为EventReceiver
声明 class MenuHandler: public irr::IEventReceiver { public: virtual bool OnEvent(const irr::SEvent&amp; event); }; 实现 bool MenuHandler::OnEvent(const irr::SEvent&amp; event) { switch(event.EventType){ //获取event类型 case irr::EET_GUI_EVENT: //GUI事件 //根据id判断是哪个GUI元素,然后做出相应操作 s32 id = event.GUIEvent.Caller->getID(); case irr::EET_MOUSE_INPUT_EVENT: //鼠标输入事件 case irr::EET_KEY_INPUT_EVENT: //键盘输入事件 //判断哪个健被按下 switch(event.KeyInput.Key) } } sqlite ygopro使用sqlite把所有卡片的信息存储在cards.cdb这个文件中.可以使用sqlitebrowser来方便的操作这个文件.
cards.cdb中有两个表,datas和texts datas的内容是卡片的信息(用数字表示),texts的内容是跟卡片有关的字符串.
datas的表头如下:
id ot alias setcode type atk def level race attribute category 需注意:这些数值的用途大部分是在卡组构造界面搜索卡片
id :表示卡片的官方代码 ot :表示卡片的限制情况 0代表禁止 3代表无限制 alias:表示别名,有些卡片被科乐美复刻了多次,比如青眼白龙,复刻后的青眼白龙的alias就是初版青眼白龙的id setcode :一个10进制数,表示卡片所属的字段,把这个数转换成16进制可得到字段, 每个字段4位16进制数.strings.conf文件中存储了所有字段 举个例子:数据库中查到的setcode最大值的卡片是"希望皇 拟声乌托邦",所属字段是"刷拉拉(0x8f)" &ldquo;我我我(0x54)&rdquo; &ldquo;隆隆隆(0x59)&rdquo; &ldquo;怒怒怒(0x82)",这张卡片的setcode是36592129229979791, 转换成16进制是82 0059 0054 008F
type :一个10进制数,转换成2进制后,表示卡片类型. atk :攻击力 def:防御力 level: 等级 or 阶级 or link值 race:种族 attribute:属性 category:一个10进制数,转换成32bit的二进制数,恰好对应卡片搜索的中的32个效果. 举个例子:随机选择了一张卡"暗之支配者-佐克&rdquo;,其category值为134217730,写成二进制是00001000000000000000000000000010,倒着看,恰好对应第二个效果"怪兽破坏"和倒数第五个效果"幸运",
至于为什么要倒着看,因为代码中是通过下面的方式设置过滤选项的
long long filter = 0x1; for(int i = 0; i &lt; 32; ++i, filter &lt;&lt;= 1) if(mainGame->chkCategory[i]->isChecked()) filter_effect |= filter; texts的内容比较简单 就不展开了.
网络部分 当一个玩家点击"新建主机"时,会同时建立一个server和client,server会立即开始监听,然后client会立即连接server,当另一个玩家点击加入游戏时,会建立一个client按照地址和端口去连接server.
当server接收到client的连接后,会新建一个bufferevent建立与client之间的连接
非TAG模式下,第三个以上的玩家再加入游戏就会变成观众.
client给server发送数据 这个操作重载了3个函数
static void SendPacketToServer(unsigned char proto); template&lt;typename ST> static void SendPacketToServer(unsigned char proto, ST&amp; st); static void SendBufferToServer(unsigned char proto, void* buffer, size_t len); 实际上发送的数据有一个固定的格式
16bit 8bit 若干附加内容 1+附加内容的字节数 proto server接收到数据后 首先会根据数据的前两个字节(packet_len)来判断数据数否正确
if(len &lt; 2) return; evbuffer_copyout(input, &amp;packet_len, 2); //将数据的前两位 (包的长度) 复制到 packet_len if(len &lt; (size_t)packet_len + 2) return; 然后跳过表示packet_len的前两个字节,从第三个字节开始处理
void NetServer::HandleCTOSPacket(DuelPlayer* dp, char* data, unsigned int len); HandleCTOSPacket函数会根据不同的proto来做出不同的反应,处理过之后会通过下一节的函数来给玩家和观战者发送数据
server给client发送数据 同样重载了3个函数
static void SendPacketToPlayer(DuelPlayer* dp, unsigned char proto); template&lt;typename ST> static void SendPacketToPlayer(DuelPlayer* dp, unsigned char proto, ST&amp; st) static void SendBufferToPlayer(DuelPlayer* dp, unsigned char proto, void* buffer, size_t len); 发送数据的格式和上文一致
这个函数执行完之后通常需要立即执行
static void ReSendToPlayer(DuelPlayer* dp); 给另一个玩家以及观战者发送相同的数据
client接收到数据后 和server类似,client首先会根据数据的前两个字节(packet_len)来判断数据数否正确
if(len &lt; 2) return; evbuffer_copyout(input, &amp;packet_len, 2); if(len &lt; (size_t)packet_len + 2) return; 然后跳过表示packet_len的前两个字节,从第三个字节开始处理
void DuelClient::HandleSTOCPacketLan(char* data, unsigned int len); HandleSTOCPacketLan函数会通过不同的proto进行让client做出不同的操作</content></entry><entry><title>关于我</title><url>http://rayrain.xyz/about.html</url><categories/><tags/><content type="html"> a righteoux</content></entry><entry><title>Markdown语法手册</title><url>http://rayrain.xyz/post/markdown-syntax/</url><categories><category>themes</category><category>syntax</category></categories><tags><tag>markdown</tag><tag>css</tag><tag>html</tag></tags><content type="html"> 本文提供了一个可以在 Hugo 内容文件中使用的基本Markdown语法示例，还展示了基本 HTML 元素在 Hugo 主题中是否使用 CSS 装饰。
标题 下面的 HTML 代码&lt;h1>—&lt;h6> 元素表示六个级别的节标题。 &lt;h1>是最高的节级别，&lt;h6>是最低的节级别。
H1 H2 H3 H4 H5 H6 段落 Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.
伊塔图？厨房里有很多东西，我不知道他们喜欢吃什么，或者他们喜欢吃什么。
引用 blockquote元素表示从另一个来源引用的内容，可选的引用必须在footer或cite元素内，也可选的内嵌更改，如注释和缩写。
引用没有归属 Tiam, ad mint andaepu dandae nostion secatur sequo quae. 注意 可以在块引用中使用 Markdown 语法。
带归属的引用 不要通过分享记忆来交流，通过交流来分享记忆。
— 罗布·派克1
表格 表不是Markdown核心规范的一部分，但是Hugo支持开箱即用。
Name Age Bob 27 Alice 23 表格内使用Markdown语法 Italics Bold Code italics bold code 图像 ![图像描述](图像地址) 示例 Google Chrome Firefox Browser
点击图像可以打开图像浏览器，快试试吧。
代码块 带有引号的代码块 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 用四个空格缩进的代码块 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 代码块引用Hugo的内部高亮短代码 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 列表类型 有序列表 First item Second item Third item 无序列表 List item Another item And another item 嵌套列表 Fruit Apple Orange Banana Dairy Milk Cheese 其他元素 — abbr, sub, sup, kbd, mark GIF 是位图图像格式。
H2O
Xn + Yn = Zn
按 CTRL+ALT+Delete 组合键结束会话。
大多数蝾螈在夜间活动，捕食昆虫、蠕虫和其他小动物。
以上引文摘自Rob Pike在2015年11月18日Gopherfest上的演讲。&#160;&#8617;&#xfe0e;</content></entry><entry><title>占位符文本显示</title><url>http://rayrain.xyz/post/placeholder-text/</url><categories/><tags><tag>markdown</tag><tag>text</tag></tags><content type="html"> 你对我的心有偏见。我向您保证，我们的生活将不会受到影响，我们的生活将会受到影响。你说你现在住在医院里，因为你的眼睛是透明的，你的眼睛是光明的，你的眼睛是光明的!
Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.
Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt
The Van de Graaf Canon
Mane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.
Iubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.
Eurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.</content></entry><entry><title>数据公式设置显示</title><url>http://rayrain.xyz/post/math-typesetting/</url><categories/><tags/><content type="html"> Hugo项目中的数学表示法可以通过使用第三方JavaScript库来实现。
在这个例子中，我们将使用 MathJax
Create a post under /content/en[zh-CN]/math.md
可以全局启用MathJax，请在项目配置中将参数math设置为true
或是在每页基础上启用MathJax，在内容文件中包括参数math: true
注意： 使用支持的TeX功能的联机参考资料
例子 重复的分数 $$ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} \equiv 1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}} {1+\frac{e^{-8\pi}} {1+\cdots} } } } $$
总和记号 $$ \left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right) $$
几何级数之和 我把接下来的两个例子分成了几行，这样它在手机上表现得更好。这就是为什么它们包含 \displaystyle。
$$ \displaystyle\sum_{i=1}^{k+1}i $$
$$ \displaystyle= \left(\sum_{i=1}^{k}i\right) +(k+1) $$
$$ \displaystyle= \frac{k(k+1)}{2}+k+1 $$
$$ \displaystyle= \frac{k(k+1)+2(k+1)}{2} $$
$$ \displaystyle= \frac{(k+1)(k+2)}{2} $$
$$ \displaystyle= \frac{(k+1)((k+1)+1)}{2} $$
乘记号 $$ \displaystyle 1 + \frac{q^2}{(1-q)}+\frac{q^6}{(1-q)(1-q^2)}+\cdots = \displaystyle \prod_{j=0}^{\infty}\frac{1}{(1-q^{5j+2})(1-q^{5j+3})}, \displaystyle\text{ for }\lvert q\rvert &lt; 1. $$
随文数式 这是一些线性数学: $$ k_{n+1} = n^2 + k_n^2 - k_{n-1} $$ ， 然后是更多的文本。
希腊字母 $$ \Gamma\ \Delta\ \Theta\ \Lambda\ \Xi\ \Pi\ \Sigma\ \Upsilon\ \Phi\ \Psi\ \Omega \alpha\ \beta\ \gamma\ \delta\ \epsilon\ \zeta\ \eta\ \theta\ \iota\ \kappa\ \lambda\ \mu\ \nu\ \xi \ \omicron\ \pi\ \rho\ \sigma\ \tau\ \upsilon\ \phi\ \chi\ \psi\ \omega\ \varepsilon\ \vartheta\ \varpi\ \varrho\ \varsigma\ \varphi $$
箭头 $$ \gets\ \to\ \leftarrow\ \rightarrow\ \uparrow\ \Uparrow\ \downarrow\ \Downarrow\ \updownarrow\ \Updownarrow $$
$$ \Leftarrow\ \Rightarrow\ \leftrightarrow\ \Leftrightarrow\ \mapsto\ \hookleftarrow \leftharpoonup\ \leftharpoondown\ \rightleftharpoons\ \longleftarrow\ \Longleftarrow\ \longrightarrow $$
$$ \Longrightarrow\ \longleftrightarrow\ \Longleftrightarrow\ \longmapsto\ \hookrightarrow\ \rightharpoonup $$
$$ \rightharpoondown\ \leadsto\ \nearrow\ \searrow\ \swarrow\ \nwarrow $$
符号 $$ \surd\ \barwedge\ \veebar\ \odot\ \oplus\ \otimes\ \oslash\ \circledcirc\ \boxdot\ \bigtriangleup $$
$$ \bigtriangledown\ \dagger\ \diamond\ \star\ \triangleleft\ \triangleright\ \angle\ \infty\ \prime\ \triangle $$
微积分学 $$ \int u \frac{dv}{dx},dx=uv-\int \frac{du}{dx}v,dx $$
$$ f(x) = \int_{-\infty}^\infty \hat f(\xi),e^{2 \pi i \xi x} $$
$$ \oint \vec{F} \cdot d\vec{s}=0 $$
洛伦茨方程 $$ \begin{aligned} \dot{x} &amp; = \sigma(y-x) \ \dot{y} &amp; = \rho x - y - xz \ \dot{z} &amp; = -\beta z + xy \end{aligned} $$
交叉乘积 这在KaTeX中是可行的，但在这种环境中馏分的分离不是很好。
$$ \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \ \frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \ \frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \end{vmatrix} $$
这里有一个解决方案:使用“mfrac”类(在MathJax情况下没有区别)的额外类使分数更小:
$$ \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \ \frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \ \frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \end{vmatrix} $$
强调 $$ \hat{x}\ \vec{x}\ \ddot{x} $$
有弹性的括号 $$ \left(\frac{x^2}{y^3}\right) $$
评估范围 $$ \left.\frac{x^3}{3}\right|_0^1 $$
诊断标准 $$ f(n) = \begin{cases} \frac{n}{2}, &amp; \text{if } n\text{ is even} \ 3n+1, &amp; \text{if } n\text{ is odd} \end{cases} $$
麦克斯韦方程组 $$ \begin{aligned} \nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \ \nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \ \nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \ \nabla \cdot \vec{\mathbf{B}} &amp; = 0 \end{aligned} $$
这些方程式很狭窄。我们可以使用(例如)添加垂直间距 [1em] 在每个换行符(\)之后。正如你在这里看到的：
$$ \begin{aligned} \nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \[1em] \nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \[0.5em] \nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \[1em] \nabla \cdot \vec{\mathbf{B}} &amp; = 0 \end{aligned} $$
统计学 固定词组：
$$ \frac{n!}{k!(n-k)!} = {^n}C_k {n \choose k} $$
分数在分数 $$ \frac{\frac{1}{x}+\frac{1}{y}}{y-z} $$
ｎ次方根 $$ \sqrt[n]{1+x+x^2+x^3+\ldots} $$
矩阵 $$ \begin{pmatrix} a_{11} &amp; a_{12} &amp; a_{13}\ a_{21} &amp; a_{22} &amp; a_{23}\ a_{31} &amp; a_{32} &amp; a_{33} \end{pmatrix} \begin{bmatrix} 0 &amp; \cdots &amp; 0 \ \vdots &amp; \ddots &amp; \vdots \ 0 &amp; \cdots &amp; 0 \end{bmatrix} $$
标点符号 $$ f(x) = \sqrt{1+x} \quad (x \ge -1) f(x) \sim x^2 \quad (x\to\infty) $$
现在用标点符号:
$$ f(x) = \sqrt{1+x}, \quad x \ge -1 f(x) \sim x^2, \quad x\to\infty $$</content></entry><entry><title>支持Emoji表情符号</title><url>http://rayrain.xyz/post/emoji-support/</url><categories/><tags><tag>emoji</tag></tags><content type="html"> 在Hugo项目中可以通过多种方式启用Emoji。
The emojify function can be called directly in templates or Inline Shortcodes.
To enable emoji globally, set enableEmoji to true in your site&rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.
馃檲 🙈 馃檳 🙉 馃檴 🙊
The Emoji cheat sheet is a useful reference for emoji shorthand codes.
N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.
.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }</content></entry></search>